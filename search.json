[{"title":"Hello World","url":"/2025/06/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Clion介绍","url":"/2025/06/18/%E6%9D%82%E8%B0%88/Clion%E4%BB%8B%E7%BB%8D/","content":"什么是CLionClion是由jetbrain开发的一款现代化的C&#x2F;C++的IDE\n\n编者因为因为vscode都装满了前端插件，感觉写C&#x2F;C++有点不太合适，况且需用DataGrip（也是jetbrains的）来管理数据库，所以顺带体验了一下Clion。\n\n\nClion怎么安装官网安装在官网下载对应版本的包即可\nsnap包安装先确保安装了snap\nsnap --version\n\n若未安装先安装snap\nsudo apt update &amp;&amp; sudo apt upgradesudo apt install snapd snapcraft\n然后使用snap一键安装clion即可\nsudo snap install clion --classic\n\n--classic：解除snap沙盒限制，确保clion能直接访问主机文件\n\n应用商店安装懂得都懂\njetbrains学生认证由于jetbrains的收费政策的变动，现在非商业用途也可以免费使用jetbrains的一些IDE（WebStorm，Rider，Clion，RustRover等），CLion代替vscode写c&#x2F;c++也成了不错的选择。但是咱们都是学生，何况咱也可能有其他工具（比如DataGrip）的需求，所以有条件的话建议进行学生认证。\n教育邮箱申请如果你的学校是全部全部学生邮箱统一注册的，那可以跳过这部分。但如果你的学校没有给你分配邮箱也不要慌，我们可以去学校官网找到邮箱申请入口，填写申请理由等上级审批就行了（理由无所谓，你都申请了学校还能不给？）\n注册jetbrains并申请学生权益打开官网登录入口，选择你喜欢的方式注册登录，然后注册申请学生包,照着填写信息即可，注意邮箱得填写教育邮箱。之后在教育邮箱认证，你便成功申请了学生权益。(不像github那复杂的认证流程)之后会跳转到licenses界面，使用你学生包的licenseID便可免费使用jetbrans的相关IDE。\n在clion填写完认证ID，再一键导入你的vscode的相关配置和插件，之后便可愉快地使用clion了。\n\n使用的技巧的文章敬请期待，计划在7月上旬到中旬更新。\n\n","categories":["杂谈","工具"],"tags":["jetbrains","C","Cpp"]},{"title":"easytier 使用指南","url":"/2025/06/08/%E6%9D%82%E8%B0%88/easytier%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","content":"介绍easytier是一个近期活跃的VPN项目，对比起传统的vpn如wireguard和openvpn（只用过这两个），最大的特点就是去中心化点对点连接。通过UDP打洞技术，即使是NAT4-NAT4限制也能成功p2p连接（官方这样说的，学校环境是NAT3,我只尝试过NAT3-NAT3）。总之，你可以通过对easytier进行简单的配置，实现异地去中心组网。\n教程安装Github项目页直接下载对应版本的发行版即可  \n\n使用\n本教程以linux版本为例，其余版本大同小异由于编者懒，本教程只面向小白，故只介绍核心功能。其余功能自行查阅官方文档\n\n解压预编译包后会有4个二进制文件，分别为easytier-core，easytier-cli，easytier-web，easytier-web-embedcore用于连接服务，cli用于查看接入网的设备，后面两个与搭建web控制台有关\n连接命令行接入sudo easytier-core -i 10.144.144.1 --network-name name --network-secret password -p tcp://public.easytier.cn:11010\n\n-i参数 表示vpn网段默认&#x2F;24--network-name和--network-secret参数 代表网络名称和密码-p参数 表示使用的对等节点，此处示例为官方公共节点\n\n注意：接入网终端要使用相同对等节点和网络名称密码才能接入同一个网\n配置文件接入sudo easytier-core -c ./config.yaml\n\n\n-c参数 代表使用的配置文件可以使用官方文档的配置文件生成器快速生成配置文件，配置方面后续会提及\n\n接入web控制台sudo easytier-core -w name\n\n\n-w参数表示接入web控制台的用户名（对应的账号可以对你的配置进行操作）官方web控制台可只写用户名，若使用自建web控制台，-w参数需指明具体的api接口例如-w udp://123.456.789.1:22020/name  \n\n配置参数配置\n\n\n参数\n解释\n说明\n\n\n\n-p\n使用的对等节点\n客户端通过对等节点的协助下进行p2p连接\n\n\n-i\n指定虚拟网卡IP\n设置本地虚拟网卡的IP地址，通常为&#x2F;24网段\n\n\n–network-name\n网络名称\n指定要加入的虚拟网络名称，需与其他节点一致\n\n\n–network-secret\n网络密码\n指定虚拟网络的密码，需与其他节点一致\n\n\n-c\n配置文件路径\n使用指定的配置文件启动\n\n\n-w\nWeb控制台用户名或API\n用于接入Web控制台，可指定用户名或完整API地址\n\n\n–log-level\n日志等级\n设置日志输出等级（如info、debug、warn等）\n\n\n–mtu\n虚拟网卡MTU\n设置虚拟网卡的最大传输单元，默认值一般为1400\n\n\n–disable-upnp\n禁用UPnP\n禁用UPnP端口映射，适用于不需要自动端口映射的环境\n\n\n–peer-refresh\n对等节点刷新间隔\n设置对等节点列表的刷新时间间隔，单位为秒\n\n\nweb控制台配置（最简单最方便）\n配置文件配置方式与web控制台几乎一至，不做额外文章\n\n基础选项上面讲过了\n高级选项\n只讲一眼看得懂又不理解的选项大部分配置项web控制台配置有说明\n\n\n\n\n配置项\n解释\n说明\n\n\n\n子网代理\n讲子网网段也代理进vpn内网\n用于实现点对网或网对网的连接\n\n\n监听地址\n监听的协议地址\nwg表示监听wireguard（用于wireguard客户端接入）， ws 和wss 是监听websocket，用于api服务\n\n\n持衡化没啥好说的，简单写个服务维护行了\n\n总结对于大部分来说，配置最快的方案是直接接入web控制台，在web控制台填写配置项运行网络即可。\n","categories":["杂谈","教程"],"tags":["vpn","easytier","p2p"]},{"title":"Vue3笔记","url":"/2025/10/01/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/Vue3/","content":"一、创建Vue3工程npm create vite@latest vue3-project --template vue-tscd vue3-projectnpm installnpm run dev\n二、编写App组件.&#x2F;src&#x2F;main.ts\nimport &#123;createApp&#125; from &quot;vue&quot;;  import App from &quot;./App.vue&quot;;  createApp(App).mount(&quot;#app&quot;);\n.&#x2F;src&#x2F;App.vue\n// 写js或ts代码&lt;script lang=&quot;ts&quot;&gt;    export default &#123;      name: &#x27;App&#x27;    &#125;  &lt;/script&gt;  // 写web的html框架&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;      &lt;p&gt;hahaha!&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;  // 写css样式&lt;style scoped&gt;    .app &#123;      background-color: gray;      box-shadow: 0 0 10px;      border-radius: 10px;      padding: 20px;    &#125;  &lt;/style&gt;\n三、核心语法1. setup()1. 概述&lt;script lang=&quot;ts&quot;&gt;    import &#123;defineComponent&#125; from &quot;vue&quot;;    export default defineComponent(&#123;    name: &#x27;App&#x27;,    setup()&#123;\t  let name = &quot;xxx&quot;;\t  let age = 18;\t  let tel = &#x27;13888888888&#x27;;\t  function changeName() &#123;\t\t  name = &#x27;xx&#x27;;\t  &#125;\t  function changeAge() &#123;\t\t  age += 1;\t  &#125;\t  function showTel() &#123;\t\t  alert(tel);\t  &#125;\t  return &#123;name, age, tel, changeName, changeAge, showTel&#125;    &#125;  &#125;)  &lt;/script&gt;\n\nVue3已经开始弱化this了此时的name和age不是响应式的\n\n2. 返回值&lt;script lang=&quot;ts&quot;&gt;    import &#123;defineComponent&#125; from &quot;vue&quot;;    export default defineComponent(&#123;    name: &#x27;App&#x27;,    setup()&#123;\t  let name = &quot;xxx&quot;;\t  let age = 18;\t  let tel = &#x27;13888888888&#x27;;\t  function changeName() &#123;\t\t  name = &#x27;xx&#x27;;\t  &#125;\t  function changeAge() &#123;\t\t  age += 1;\t  &#125;\t  function showTel() &#123;\t\t  alert(tel);\t  &#125;\t  return () =&gt; &#x27;haha&#x27;     &#125;  &#125;)  &lt;/script&gt;\n\n当setup()返回值是一个渲染函数时，返回内容会直接渲染到页面。\n\n3. Setup()与OptionsAPI&lt;script lang=&quot;ts&quot;&gt;    import &#123;defineComponent&#125; from &quot;vue&quot;;    export default defineComponent(&#123;    name: &#x27;App&#x27;,    data() &#123;\t  a: 100,\t  c: this.name,// 可以读到setup中的name\t  d: 900    &#125;,    method: &#123;\t  b() &#123;\t    console.log(&#x27;b&#x27;);\t  &#125;    &#125;,    setup() &#123;\t  let name = &quot;xxx&quot;;\t  let age = 18;\t  let tel = &#x27;13888888888&#x27;;\t  let e = d; // 报错，setup()读不到data的数据\t  function changeName() &#123;\t\t  name = &#x27;xx&#x27;;\t  &#125;\t  function changeAge() &#123;\t\t  age += 1;\t  &#125;\t  function showTel() &#123;\t\t  alert(tel);\t  &#125;\t  return &#123;name, age, tel, changeName, changeAge, showTel&#125;    &#125;  &#125;)  &lt;/script&gt;\n4. 语法糖&lt;script lang=&quot;ts&quot;&gt;    import &#123;defineComponent&#125; from &quot;vue&quot;;    export default defineComponent(&#123;    name: &#x27;App&#x27;  &#125;)  &lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt;    let name = &quot;xxx&quot;;  let age = 18;  let tel = &#x27;13888888888&#x27;;  function changeName() &#123;\t  name = &#x27;xx&#x27;;  &#125;  function changeAge() &#123;\t  age += 1;  &#125;  function showTel() &#123;\t  alert(tel);  &#125;&lt;/script&gt;\n\n在&lt;script&gt;加setup属性可以省略setup()和return部分 \n\n&lt;script setup lang=&quot;ts&quot;&gt;   defineOptions(&#123; name: &#x27;App&#x27; &#125;);  let name = &quot;xxx&quot;;  let age = 18;  let tel = &#x27;13888888888&#x27;;  function changeName() &#123;\t  name = &#x27;xx&#x27;;  &#125;  function changeAge() &#123;\t  age += 1;  &#125;  function showTel() &#123;\t  alert(tel);  &#125;&lt;/script&gt;\n\n可以用宏定义defineOptions(&#123;&#125;)来设置组件名称\n\n2. 响应式1. ref定义基本类型数据&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  defineOptions(&#123; name: &#x27;App&#x27; &#125;);  let name = ref(&quot;xxx&quot;); // 加ref()让数据变成对象  let age = ref(18);  let tel = &#x27;13888888888&#x27;;  function changeName() &#123;\t  name.value = &#x27;xx&#x27;; // 对value值进行修改  &#125;  function changeAge() &#123;\t  age.value += 1;  &#125;  function showTel() &#123;\t  alert(tel);  &#125;&lt;/script&gt;&lt;template&gt;    &lt;div class=&quot;app&quot;&gt;      &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; // vue自动解包，不需要.value    &lt;/div&gt;&lt;/template&gt;\n2. reactive定义对象类型的数据&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;reactive&#125; from &#x27;vue&#x27;;  defineOptions(&#123; name: &#x27;Car&#x27; &#125;);  let car = reactive(&#123;brand: &#x27;奔驰&#x27;, price: 100&#125;);  function changePrice() &#123;    car.price += 10;  &#125;&lt;/script&gt;&lt;template&gt;    &lt;div class=&quot;car&quot;&gt;      &lt;h2&gt;一辆&#123;&#123;car.brand&#125;&#125;车，价值&#123;&#123;car.price&#125;&#125;万&lt;/h2&gt;    &lt;button @click=&quot;changePrice&quot;&gt;修改汽车价格&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\nreactive只能定义对象类型响应数据\n\n3. ref定义对象类型的数据略\n4. ref对比reactive1. 宏观角度\nref用来定义：基本类型数据，对象类型数据\nreactive用来定义：对象类型数据\n\n2. 区别\nref创建变量必须使用.value（可以用volar插件自动加.value）\nreactive重新分配一个新对象，会失去响应式（可以用Object.assign去整体替换）。\n\n3.使用原则\n若需要一个基本类型的响应式数据，必须用ref\n若需要一个响应式对象，层级不深，ref和reactive都可以\n若需要一个响应式对象，且层级较深，建议使用reactive\n\n5.toRefs与toRef新版本直接解构即可，不再会丢失响应性\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;reactive, toRefs, toRef&#125; from &#x27;vue&#x27;;  let person = reactive(&#123;    name: &quot;xxx&quot;,    age: 18  &#125;)  let &#123;name, age&#125; = toRefs(person) ；  let n1 = toRef(person,&#x27;age&#x27;)；&lt;/script&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;    &lt;/div&gt;&lt;/template&gt;\n\n使用toRefs对响应式对象person进行解构赋值，确保解构后的name和age仍保持响应性解构后的属性需通过.value访问，与原始响应式对象属性双向绑定\n\n3. computed()&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref, computed&#125; from &#x27;vue&#x27;;    let lastName = ref(&#x27;张&#x27;);  let firstName = ref(&#x27;三&#x27;);  let fullName = computed(() =&gt; &#123;    return lastName.value.slice(0, 1).toUpperCase() + lastName.value.slice(1) + &#x27;-&#x27; + firstName.value;  &#125;)  /*  let fullName = computed(&#123;    get() &#123;      return lastName.value.slice(0, 1).toUpperCase() + lastName.value.slice(1) + &#x27;-&#x27; + firstName.value;    &#125;,    set(val) &#123;      const [str1, str2] = val.split(&#x27;-&#x27;);      lastName.value = str1;      firstName.value = str2;    &#125;  &#125;)  */&lt;/script&gt;&lt;template&gt;    &lt;div class=&quot;person&quot;&gt;    姓：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;    名：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;    全名: &lt;span&gt;&#123;&#123;lastName&#125;&#125;-&#123;&#123;firstName&#125;&#125;&lt;/span&gt; &lt;br&gt;  &lt;/div&gt;&lt;/template&gt;\n\ncomputed会缓存计算结果，只有当其依赖的响应式数据（如ref或reactive变量）发生变化时才会重新计算。computed是只读的，使用注释的方法可以实现可读写\n\n4. watch()\n作用：监视数据的变化\n特点：Vue3中的watch只能监视以下四种数据：\nref定义的数据\nreactive定义的数据\n函数返回一个值（getter函数）\n一个包含上述的数组\n\n\n\n情况一watch监视ref定义的基本类型数据\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref, watch&#125; from &#x27;vue&#x27;;    let sum = ref(0);    function changeSum() &#123;    sum.value +=1;  &#125;    const stopWatch = watch(sum, (newValue, oldValue) =&gt; &#123;    console.log(&#x27;sum is Changed&#x27;, newValue, oldValue)    if(newValue &gt; 10) &#123;\t  stopWatch();    &#125;  &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;sum+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\nwatch()函数会返回一个​​停止监听的函数，调用该函数可以停止监视第二个参数中的newValue和oldValue指向的是地址\n\n情况二watch监视ref定义的对象类型数据\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref, watch&#125; from &#x27;vue&#x27;;    let person = &#123;    name: &#x27;xxx&#x27;,    age: 18  &#125;    function changeName() &#123;    person.value.name += &#x27;~&#x27;;  &#125;  function changeAge() &#123;    person.value.age += 1;  &#125;  function changePerson() &#123;    person.value = &#123;name: &#x27;yyy&#x27;, age: 90&#125;;  &#125;  watch(person,(newValue, oldValue) =&gt; &#123;    console.log(&#x27;person is Changed&#x27;, newValue, oldValue);  &#125;,&#123;deep: true, immediated: true&#125;) &lt;/script&gt;&lt;template&gt;  &lt;div&gt;\t&lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;改年龄&lt;/button&gt;    &lt;button @click=&quot;changePerson&quot;&gt;改人&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n若按情况一的写法，watch只会监视对象的地址值，而不关心对象属性的变化若想监视内部属性，则需要手动开启深度监视&#123;deep: true&#125;&#123;immediated: true&#125;可以在开始是调用warch的回调函数，oldValue等于undefined\n\n情况三watch监视reactive定义的对象类型数据\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;reactive, watch&#125; from &#x27;vue&#x27;;    let person = &#123;    name: &#x27;xxx&#x27;,    age: 18  &#125;    function changeName() &#123;    person.name += &#x27;~&#x27;;  &#125;  function changeAge() &#123;    person.age += 1;  &#125;  function changePerson() &#123;    Object.assign(person, &#123;name: &#x27;yyy&#x27;, age: 90&#125;);  &#125;  watch(person, () =&gt; &#123;    console.log(&#x27;person is Changed&#x27;, newValue, oldValue);  &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;\t&lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;改年龄&lt;/button&gt;    &lt;button @click=&quot;changePerson&quot;&gt;改人&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n默认开启深度监视，且不可关闭\n\n情况四watch监视ref或reactive定义的对象类型数据中的某个属性，注意以下几点：\n\n若该属性值不是对象类型，需要改写为函数形式\n若该属性值仍是对象类型，可以直接写，但建议也写成函数。否则在该属性整体改变时，​依赖追踪失效​导致监听不触发\n\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;reactive, watch&#125; from &#x27;vue&#x27;;   let person = reactive(&#123;     name: &#x27;xxx&#x27;,     age: 18,     cars: &#123;       car1: &#x27;奔驰&#x27;,       car2: &#x27;宝马&#x27;     &#125;   &#125;)        function changeName() &#123;    person.name += &#x27;~&#x27;;  &#125;  function changeAge() &#123;    person.age += 1;  &#125;  function changeCar1() &#123;    person.cars.car1 = &#x27;小米&#x27;;  &#125;  function changeCar2() &#123;    person.cars.car2 = &#x27;理想&#x27;;  &#125;  function changeCars() &#123;    person.cars = &#123;      car1: &#x27;爱玛&#x27;,      car2: &#x27;雅迪&#x27;    &#125;  &#125;    watch(() =&gt; person.name, (newValue, oldValue) =&gt; &#123;    console.log(&quot;name is changed&quot;)  &#125;)  watch(() =&gt; person.cars, (newValue, oldValue) =&gt; &#123;    console.log(&quot;cars &quot;)  &#125;,&#123;deep: true&#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;\t&lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;汽车：&#123;&#123;person.cars.car1&#125;&#125;,&#123;&#123;person.cars.car2&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;改年龄&lt;/button&gt;    &lt;button @click=&quot;changeCar1&quot;&gt;改第一台车&lt;/button&gt;    &lt;button @click=&quot;changeCar2&quot;&gt;改第二台车&lt;/button&gt;    &lt;button @click=&quot;changeCars&quot;&gt;改全部车&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n情况五watch监视上述多个数据\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;reactive, watch&#125; from &#x27;vue&#x27;;   let person = reactive(&#123;     name: &#x27;xxx&#x27;,     age: 18,     cars: &#123;       car1: &#x27;奔驰&#x27;,       car2: &#x27;宝马&#x27;     &#125;   &#125;)        function changeName() &#123;    person.name += &#x27;~&#x27;;  &#125;  function changeAge() &#123;    person.age +=&#x27;1&#x27;;     &#125;  function changeCar1() &#123;    person.cars.car1 = &#x27;小米&#x27;;  &#125;  function changeCar2() &#123;    person.cars.car2 = &#x27;理想&#x27;;  &#125;  function changeCars() &#123;    person.cars = &#123;      car1: &#x27;爱玛&#x27;,      car2: &#x27;雅迪&#x27;    &#125;  &#125;    watch([() =&gt; person.name, () =&gt; person.cars.car1], (newValue, oldValue) =&gt; &#123;    console.log(&quot;name is changed&quot;)  &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;person&quot;&gt;\t&lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;汽车：&#123;&#123;person.cars.car1&#125;&#125;,&#123;&#123;person.cars.car2&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeName&quot;&gt;改名字&lt;/button&gt;    &lt;button @click=&quot;changeAge&quot;&gt;改年龄&lt;/button&gt;    &lt;button @click=&quot;changeCar1&quot;&gt;改第一台车&lt;/button&gt;    &lt;button @click=&quot;changeCar2&quot;&gt;改第二台车&lt;/button&gt;    &lt;button @click=&quot;changeCars&quot;&gt;改全部车&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n5. watchEffect()&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref, watch, watchEffect&#125; from &#x27;vue&#x27;;    let temp = ref(10);  let height = ref(0);    function changeTemp() &#123;    temp.value += 10;  &#125;  function changeHeight() &#123;    height.value += 10;  &#125;  // watch 实现  watch([temp, hejight], (value) =&gt; &#123;    let [newTemp, Height] = value;    if(newTemp &gt;= 60 || newHeight &gt;= 80) &#123;      console.log(&#x27;@@@&#x27;);    &#125;    console.log(newTemp, Height);  &#125;)  // watchEffect 实现  watchEffect(() =&gt; &#123;    if(temp.value &gt;= 60 || height.value &gt;= 80)&#123;\t  console.log(&#x27;@@@&#x27;);    &#125;  &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;当前水温为：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;    &lt;h2&gt;当前水位为：&#123;&#123;height&#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeTemp&quot;&gt;temp+10&lt;/button&gt;    &lt;button @click=&quot;changeHeight&quot;&gt;height+10&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n自动追踪回调函数内使用的响应式数据（如 temp.value和 height.value），无需显式声明依赖。初始化时立即执行一次回调，用于捕获初始状态。无法直接获取变化前的值\n\n6. 标签的ref属性&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;    let title2 = ref();    function showLog() &#123;    console.log(title2);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h1&gt;中国&lt;/h1&gt;    &lt;h2 ref=&quot;title2&quot;&gt;青海&lt;/h2&gt;    &lt;h3&gt;西宁&lt;/h3&gt;    &lt;button @click=&quot;showLog&quot;&gt;click me!&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n推荐使用标签的ref属性来获取元素，而不是根据id进行DOM操作。因为ref容器是局部的，而DOM操作容易获取到其他组件的元素。\n\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref, defineExpose&#125; from &#x27;vue&#x27;;    let title2 = ref();  let a = ref(0);  let b = ref(1);  let c = ref(2);  function showLog() &#123;    console.log(title2);  &#125;    defineExpose(&#123;a, b, c&#125;);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h1&gt;中国&lt;/h1&gt;    &lt;h2 ref=&quot;title2&quot;&gt;青海&lt;/h2&gt;    &lt;h3&gt;西宁&lt;/h3&gt;    &lt;button @click=&quot;showLog&quot;&gt;click me!&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n当父组件通过ref属性来获得子组件的元素时，默认是无法获取任何元素的。必须在子组件通过defineExpose()将对象暴露\n\n7. propsindex.ts\nexport interface PersonInterface &#123;  id: string,  name: string,  age: number&#125;export type Persons = PersonInterface[];\nApp.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import Person from &#x27;./components/Person.vue&#x27;;  import &#123;type Persons&#125; from &#x27;@/types&#x27;  import &#123;reactive&#125; from &#x27;vue&#x27;;    let PersonList = reactive&lt;Persons&gt;([    &#123;id: &#x27;dhfgajsh01&#x27;, name: &#x27;xxx&#x27;, age: 18&#125;,    &#123;id: &#x27;dhfgajsh02&#x27;, name: &#x27;yyy&#x27;, age: 19&#125;,    &#123;id: &#x27;dhfgajsh03&#x27;, name: &#x27;zzz&#x27;, age: 17&#125;  ])&lt;/script&gt;&lt;template&gt;  &lt;Person/ :List=&quot;PersonList&quot;&gt;// 把列表传给Person组件&lt;/template&gt;\nPerson.vue\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;defineProps&#125; from &#x27;vue&#x27;;  import &#123;Persons&#125; from &#x27;@/types&#x27;    // 只接收List  defineProps([&#x27;List&#x27;]); // 必须写成数组的形式    // 接收List + 类型限制  defineProps&lt;&#123;List: Person&#125;&gt;();    // 接收List + 类型限制 + 限制必要性 + 指定默认值  const &#123; List = [&#123; name: &#x27;默认姓名&#x27;, age: 18 &#125;] &#125; = defineProps&lt;&#123; List?: Person[] &#125;&gt;();&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;persons&quot;&gt;    &lt;ul&gt;      &lt;li v-for = &quot;p in List&quot; :key = &quot;p.id&quot;&gt;        &#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;\n8. 生命周期组件的生命周期创建 挂载 更新 销毁\n1. Vue2 生命周期\n\n\n生命周期\n钩子\n\n\n\n创建\nbeforeCreate(),created()\n\n\n挂载\nbeforeMount(),mounted()\n\n\n更新\nbeforeUpdate,updated()\n\n\n销毁\nbeforeDestroy(),destroyed()\n\n\n2. Vue3 生命周期\n\n\n生命周期\n钩子\n\n\n\n创建\n在setup函数中便是创建阶段\n\n\n挂载\nonBeforeMount(),onMounted()\n\n\n更新\nonBeforeUpdate,onUpdated()\n\n\n销毁\nonBeforeUnmount(),onUnmounted()\n\n\n9. Hooks&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;    let sum = ref(0);  let count = ref(1);    function changeSum() &#123;    sum.value += 10;  &#125;  function changeCount() &#123;    count.value += 1;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;求和：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;计数：&#123;&#123; count &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;sum+10&lt;/button&gt;    &lt;button @click=&quot;changeCount&quot;&gt;count+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n通过Hooks将上述组件脚本中的不同功能的数据和函数封装\n\nuseSum.ts:  import &#123;ref&#125; from &#x27;vue&#x27;;export default function()&#123;  let sum = ref(0);  function changeSum() &#123;    sum.value += 10;  &#125;    return &#123;sum, changeSum&#125;;&#125;\nuseCount.ts:\t  import &#123;ref&#125; from &#x27;vue&#x27;;export default function()&#123;     let count = ref(1);        function changeCount() &#123;       count.value += 1;     &#125;    return &#123;count, changeCount&#125;;&#125;\nMath.vue:  &lt;script setup lang=&quot;ts&quot;&gt;   import useSum from &#x27;@/hooks/useSum&#x27;;  import useCount from &#x27;@/hooks/useCount&#x27;;    const &#123;sum, changeSum&#125; = useSum();  const &#123;count, changeCount&#125; = useCount();&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;求和：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;    &lt;h2&gt;计数：&#123;&#123; count &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeSum&quot;&gt;sum+10&lt;/button&gt;    &lt;button @click=&quot;changeCount&quot;&gt;count+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n四、路由1. 安装路由器组件npm i vue-router\n2. 基本切换效果src/App.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;div class=&quot;navigate&quot;&gt;      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/RouterLink &gt;      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;Home&lt;/RouterLink &gt;      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;News&lt;/RouterLink &gt;    &lt;/div&gt;    &lt;div&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/About.vue:\n&lt;script setup lang=&quot;ts&quot;&gt; &lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;about&quot;&gt;    &lt;p&gt;这是一个测试组件&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/Home.vue:\n&lt;script setup lang=&quot;ts&quot;&gt; &lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;主页&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/News.vue:\n&lt;script setup lang=&quot;ts&quot;&gt; &lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;news 1&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;news 2&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;news 3&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/router/index.ts:\nimport &#123;createRouter, createWebHistory&#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/viewsviews/Home.vue&#x27;;import About from &#x27;@/viewsviews/About.vue&#x27;;import News from &#x27;@/viewsviews/News.vue&#x27;;const router = createRouter(&#123;  history: createWebHistory(),  routes:[&#123;      path: &#x27;/home&#x27;,      conponent: Home     &#125;,&#123;      path: &#x27;/about&#x27;,      conponent: About     &#125;,&#123;      path: &#x27;/news&#x27;,      conponent: News     &#125;  ]&#125;);export default reouter\nsrc/main.ts:\nimport &#123;createApp&#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;;const app = createApp(App);app.use(router);app.mount(&#x27;#app&#x27;);\n3. 注意事项\n路由组件一般放在pages或views文件夹，一般组件放在components文件夹。\n通过点击导航，视觉效果消失了的路由组件，默认是被卸载的，需要时会重新挂载\n\n4. 路由器工作模式\nhistory模式\n优点：URL更加美观，不带#，更接近传统网站URL。缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会用404错误。\n\n\nhash模式\n优点：兼容性更好，因为不需要服务端处理路径。缺点：URL带#不太美观，而且在SEO优化方面相对较差。\n\n\n\n5. to的两种写法&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;div class=&quot;navigate&quot;&gt;      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/RouterLink &gt;      &lt;RouterLink :to=&quot;&#123;path: &#x27;/home&#x27;&#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/RouterLink &gt;      &lt;RouterLink :to=&quot;&#123;name: &#x27;关于&#x27;&#125;&quot; active-class=&quot;active&quot;&gt;News&lt;/RouterLink &gt;      // 下面会讲到命名路由    &lt;/div&gt;    &lt;div&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n6. 命名路由import &#123;createRouter, createWebHistory&#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;const router = createRouter(&#123;  history: createWebHistory(),  routes:[&#123;      name: &#x27;主页&#x27;,      path: &#x27;/home&#x27;,      conponent: Home     &#125;,&#123;      name: &#x27;关于&#x27;,      path: &#x27;/about&#x27;,      conponent: About     &#125;,&#123;      name: &#x27;新闻&#x27;,      path: &#x27;/news&#x27;,      conponent: News     &#125;  ]&#125;);export default router;\n7. 嵌套路由src/views/News.vue\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;react&#125; from &#x27;vue&#x27;;    import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;    const newsList = reactive([    &#123;id: &#x27;asda001&#x27;, title:&#x27;如何学好前端&#x27;, content:&#x27;菜就多练&#x27;&#125;,    &#123;id: &#x27;asda002&#x27;, title:&#x27;最好的语言&#x27;, content:&#x27;PHP&#x27;&#125;,    &#123;id: &#x27;asda003&#x27;, title:&#x27;国庆假期该干什么&#x27;, content:&#x27;睡觉&#x27;&#125;  ])&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;&lt;RouterLink to=&quot;/news/detail&quot;&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;news-content&quot;&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/Detail.vue:\n&lt;script setup lang=&quot;ts&quot;&gt; &lt;/script&gt;&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：xxx&lt;/li&gt;    &lt;li&gt;标题：xxx&lt;/li&gt;    &lt;li&gt;内容：xxx&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;\nsrc/router/index.ts:\nimport &#123;createRouter, createWebHistory&#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;import Detail from &#x27;@/views/Detail.vue&#x27;;const router = createRouter(&#123;  history: createWebHistory(),  routes:[&#123;      name: &#x27;主页&#x27;,      path: &#x27;/home&#x27;,      conponent: Home     &#125;,&#123;      name: &#x27;关于&#x27;,      path: &#x27;/about&#x27;,      conponent: About,      children: [&#123;          name: &#x27;详情&#x27;,          path: &#x27;detail&#x27;, // 子路径无前导斜杠          component: Detail        &#125;      ]    &#125;,&#123;      name: &#x27;新闻&#x27;,      path: &#x27;/news&#x27;,      conponent: News     &#125;  ]&#125;);export default router;\n8. query参数src/views/Detail.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;getRoute&#125; from &#x27;vue-router&#x27;;    const route = uesRoute();  &lt;/script&gt;&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; route.query.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; route.query.title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; route.query.content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;\nsrc/views/News.vue\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;react&#125; from &#x27;vue&#x27;;    import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;    const newsList = reactive([    &#123;id: &#x27;asda001&#x27;, title:&#x27;如何学好前端&#x27;, content:&#x27;菜就多练&#x27;&#125;,    &#123;id: &#x27;asda002&#x27;, title:&#x27;最好的语言&#x27;, content:&#x27;PHP&#x27;&#125;,    &#123;id: &#x27;asda003&#x27;, title:&#x27;国庆假期该干什么&#x27;, content:&#x27;睡觉&#x27;&#125;  ])&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;ul&gt;      &lt;!-- 第一种写法 --&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;&lt;RouterLink :to=&quot;`/news/detail?$id=&#123;news.id&#125;&amp;title=$&#123;news.title&#125;&amp;content=$&#123;news.content&#125;`&quot;&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;&lt;/li&gt;      &lt;!-- 第二种写法 --&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;        &lt;RouterLink           :to=&quot;&#123;            path: &#x27;/news/detail&#x27;,            query:&#123;              id: news.id,              titile: news.title,              content: news.content            &#125;          &#125;&quot;        &gt;          &#123;&#123; news.title &#125;&#125;        &lt;/RouterLink&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;news-content&quot;&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n9. params参数src/views/Detail.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;useRoute&#125; from &#x27;vue-router&#x27;;    const route = uesRoute();  &lt;/script&gt;&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; route.parmas.id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; route.parmas.title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; route.parmas.content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;\nsrc/views/News.vue\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;react&#125; from &#x27;vue&#x27;;    import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;    const newsList = reactive([    &#123;id: &#x27;asda001&#x27;, title:&#x27;如何学好前端&#x27;, content:&#x27;菜就多练&#x27;&#125;,    &#123;id: &#x27;asda002&#x27;, title:&#x27;最好的语言&#x27;, content:&#x27;PHP&#x27;&#125;,    &#123;id: &#x27;asda003&#x27;, title:&#x27;国庆假期该干什么&#x27;, content:&#x27;睡觉&#x27;&#125;  ])&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;ul&gt;      &lt;!-- 第一种写法 --&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;&lt;RouterLink :to=`&quot;/news/detail/$&#123;new.id&#125;/$&#123;news.title&#125;/$&#123;news.content&#125;&quot;`&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;&lt;/li&gt;      &lt;!-- 第二种写法 --&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;        &lt;RouterLink           :to=&quot;&#123;            name: &#x27;详情&#x27;,             query:&#123;              id: news.id,              titile: news.title,              content: news.content            &#125;          &#125;&quot;        &gt;          &#123;&#123; news.title &#125;&#125;        &lt;/RouterLink&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;news-content&quot;&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/router/index.ts:\nimport &#123;createRouter, createWebHistory&#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;import Detail from &#x27;@/views/Detail.vue&#x27;;const router = createRouter(&#123;  history: createWebHistory(),  routes:[&#123;      name: &#x27;主页&#x27;,      path: &#x27;/home&#x27;,      conponent: Home     &#125;,&#123;      name: &#x27;关于&#x27;,      path: &#x27;/about&#x27;,      conponent: About,      children: [&#123;          name: &#x27;详情&#x27;,          path: &#x27;detail/:id/:title/:content?&#x27;, // 需用占位符占位,问号表示可传可不传          component: Detail        &#125;      ]    &#125;,&#123;      name: &#x27;新闻&#x27;,      path: &#x27;/news&#x27;,      conponent: News     &#125;  ]&#125;);export default router;\n\n传递params参数时，必须在路由规则里提前占位传递params参数时，to对象写法传参必须用name，不能用path\n\n10. props配置src/views/Detail.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;     defineProps([&#x27;id&#x27;, &#x27;title&#x27;, &#x27;content&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;ul class=&quot;news-list&quot;&gt;    &lt;li&gt;编号：&#123;&#123; id &#125;&#125;&lt;/li&gt;    &lt;li&gt;标题：&#123;&#123; title &#125;&#125;&lt;/li&gt;    &lt;li&gt;内容：&#123;&#123; content &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;\nsrc/views/News.vue\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;react&#125; from &#x27;vue&#x27;;    import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;    const newsList = reactive([    &#123;id: &#x27;asda001&#x27;, title:&#x27;如何学好前端&#x27;, content:&#x27;菜就多练&#x27;&#125;,    &#123;id: &#x27;asda002&#x27;, title:&#x27;最好的语言&#x27;, content:&#x27;PHP&#x27;&#125;,    &#123;id: &#x27;asda003&#x27;, title:&#x27;国庆假期该干什么&#x27;, content:&#x27;睡觉&#x27;&#125;  ])&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;news&quot;&gt;    &lt;ul&gt;      &lt;!-- 第一种写法 --&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;&lt;RouterLink :to=`&quot;/news/detail/$&#123;new.id&#125;/$&#123;news.title&#125;/$&#123;news.content&#125;&quot;`&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt;&lt;/li&gt;      &lt;!-- 第二种写法 --&gt;      &lt;li v-for=&quot;news in newsList&quot;, key=&quot;news.id&quot;&gt;        &lt;RouterLink           :to=&quot;&#123;            name: &#x27;详情&#x27;,             query:&#123;              id: news.id,              titile: news.title,              content: news.content            &#125;          &#125;&quot;        &gt;          &#123;&#123; news.title &#125;&#125;        &lt;/RouterLink&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;news-content&quot;&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/router/index.ts:\nimport &#123;createRouter, createWebHistory&#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;import Detail from &#x27;@/views/Detail.vue&#x27;;const router = createRouter(&#123;  history: createWebHistory(),  routes:[&#123;      name: &#x27;主页&#x27;,      path: &#x27;/home&#x27;,      conponent: Home     &#125;,&#123;      name: &#x27;关于&#x27;,      path: &#x27;/about&#x27;,      conponent: About,      children: [&#123;          name: &#x27;详情&#x27;,          path: &#x27;detail/:id/:title/:content?&#x27;, // 需用占位符占位,问号表示可传可不传          component: Detail,          // 第一种方法：将路由收到的pramas参数作为props传给路由组件          props: true,          // 第二种方法：函数写法，自由决定将什么参数作为props传给路由组件          props(route) &#123;            return &#123;              return reoute.query;            &#125;          &#125;          // 第三种方法：对象写法，自由决定将什么参数作为props传给路由组件(写死的，应用场景少)          props: &#123;            a: 100,            b: 200,            c: 300          &#125;        &#125;      ]    &#125;,&#123;      name: &#x27;新闻&#x27;,      path: &#x27;/news&#x27;,      conponent: News     &#125;  ]&#125;);export default router;\n10. replace属性src/App.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;RouterView, RouterLink&#125; from &#x27;vue-router&#x27;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;app&quot;&gt;    &lt;div class=&quot;navigate&quot;&gt;      &lt;RouterLink replace to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/RouterLink &gt;      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;Home&lt;/RouterLink &gt;      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;News&lt;/RouterLink &gt;    &lt;/div&gt;    &lt;div&gt;      &lt;RouterView&gt;&lt;/RouterView&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;\n\n加上replace属性后，跳转后不再可以使用浏览器的回退回退上一页。默认情况是push模式\n\n10. 编程式路由导航src/views/Home.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;onMounted&#125; from &#x27;vue&#x27;;  import &#123;useRouter&#125; from &#x27;vue-router&#x27;;    const router = useRouter();    onMounted(() =&gt; &#123;    setTimeout(() =&gt; &#123;      router.push(&#x27;/news&#x27;)    &#125;,3000);  &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;home&quot;&gt;    &lt;p&gt;主页&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\npush()传参方式和&lt;RouterLink&gt;的to属性相同。\n\n11. 重定向src/router/index.ts:\nimport &#123;createRouter, createWebHistory&#125; from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;import News from &#x27;@/views/News.vue&#x27;;import Detail from &#x27;@/views/Detail.vue&#x27;;const router = createRouter(&#123;  history: createWebHistory(),  routes:[&#123;      name: &#x27;主页&#x27;,      path: &#x27;/home&#x27;,      conponent: Home     &#125;,&#123;      name: &#x27;关于&#x27;,      path: &#x27;/about&#x27;,      conponent: About,      children: [&#123;          name: &#x27;详情&#x27;,          path: &#x27;detail/:id/:title/:content?&#x27;, // 需用占位符占位,问号表示可传可不传          component: Detail      ]    &#125;,&#123;      name: &#x27;新闻&#x27;,      path: &#x27;/news&#x27;,      conponent: News     &#125;,&#123;      path: &#x27;/&#x27;,      redirect: &#x27;/home&#x27;    &#125;  ]&#125;);export default router;\n\n将path路径重定向到redirect路径\n\n五、pinia1. 搭建pinia环境npm i pinia\nsrc/main.ts:\nimport &#123;createApp&#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;// 引入piniaimport &#123;creatPinia&#125; from &#x27;pinia&#x27;;const app = createApp(App);// 创建piniaconst pinia = createPinia();// 安装piniaapp.use(pinia);app.mount(&#x27;#app&#x27;);\n2. 存储读取数据src/store/Count.ts:\nimport &#123;defineStore&#125; from &#x27;pinia&#x27;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;  state() &#123;    return &#123;      count: 6    &#125;;  &#125;&#125;);\nsrc/components/Count.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import &#123;useCountStore&#125; from &#x27;@/store/Count&#x27;;    const countStore = useCountStore();    function changeCount() &#123;    countStore.count += 1;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;计数：&#123;&#123; countStore.count &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCount&quot;&gt;countStore.count+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n3. 修改数据src/components/Count.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import &#123;useCountStore&#125; from &#x27;@/store/Count&#x27;;    const countStore = useCountStore();    function changeCount() &#123;    // 第一种方式    countStore.count += 1;     // 第二种方式    countStore.$patch(&#123;      count += 1    &#125;);    // 第三种方式    countStore.add(10 );  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;计数：&#123;&#123; countStore.count &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCount&quot;&gt;countStore.count+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/store/Count.ts:\nimport &#123;defineStore&#125; from &#x27;pinia&#x27;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;  actions: &#123;    add(value)&#123;      this.count += value;    &#125;  &#125;,  state() &#123;    return &#123;      count: 6    &#125;;  &#125;&#125;);\n\n\n直接修改​​：直接操作状态属性每次修改都会触发独立的响应式更新，在 DevTools 中会产生多条记录$patch批量修改​​：将多个修改合并为一次响应式更新，在 DevTools 中只显示一条记录，减少响应式触发次数，适合性能优化Action 修改​​：在 Store 中定义 actions方法，支持参数传递、异步操作和复杂业务逻辑，提高代码复用性和可维护性\n\n4. storeToRefs()src/components/Count.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import &#123;useCountStore&#125; from &#x27;@/store/Count&#x27;;  import &#123;storeToRefs&#125; from &#x27;pinia&#x27;;    const countStore = useCountStore();    const &#123;count&#125; = storeToRefs(countStore);    function changeCount() &#123;    countStore.$patch(&#123;      count += 1    &#125;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;计数：&#123;&#123; count &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCount&quot;&gt;count+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n对 Pinia Store 进行解构赋值时，若直接使用 toRefs()会将所有属性（包括方法）强制转换为响应式引用，造成不必要的性能开销。推荐使用 storeToRefs()，它仅针对 state 和 getters 生成响应式引用，避免对 actions 等非状态数据做无效处理，从而优化性能。\n\n5. getterssrc/store/Count.ts:\nimport &#123;defineStore&#125; from &#x27;pinia&#x27;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;  actions: &#123;    add(value)&#123;      this.count += value;    &#125;  &#125;,  state() &#123;    return &#123;      count: 6    &#125;;  &#125;,  getters:&#123;    bigCount(state)&#123;      return state.count * 10;    &#125;,    smallCount(state)&#123;      return state.count / 10;    &#125;  &#125;&#125;);\n6. &#96;$subscribe()src/components/Count.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import &#123;useCountStore&#125; from &#x27;@/store/Count&#x27;;  import &#123;storeToRefs&#125; from &#x27;pinia&#x27;;    const countStore = useCountStore();    const &#123;count&#125; = storeToRefs(countStore);    countStore.$subscribe((mutate, state) =&gt; &#123;    console.log(countStore中数据发生了变化);    localStorage.setItem(&#x27;count&#x27;,JSON.stringify(state.count)); // 当值发生变化后，将新数据存入浏览器缓存  &#125;)  function changeCount() &#123;    countStore.$patch(&#123;      count += 1    &#125;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;water&quot;&gt;    &lt;h2&gt;计数：&#123;&#123; count &#125;&#125;&lt;/h2&gt;    &lt;button @click=&quot;changeCount&quot;&gt;count+1&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;`````src/store/Count.ts`:```typescriptimport &#123;defineStore&#125; from &#x27;pinia&#x27;;export const useCountStore = defineStore(&#x27;count&#x27;, &#123;  actions: &#123;    add(value)&#123;      this.count += value;    &#125;  &#125;,  state() &#123;    return &#123;      count: JSON.parse(localStorage.getItem(&#x27;count&#x27;) as string) || []; // count的值优先从用户的浏览器缓存中获取    &#125;;  &#125;,  getters:&#123;    bigCount(state)&#123;      return state.count * 10;    &#125;,    smallCount(state)&#123;      return state.count / 10;    &#125;  &#125;&#125;);\n\n通过订阅可以实现网页刷新数据不丢失\n\n7. store的组合式写法src/store/Count.ts:\nimport &#123;defineStore&#125; from &#x27;pinia&#x27;;import &#123;reactive&#125; from &#x27;vue&#x27;;export const useCountStore = defineStore(&#x27;count&#x27;, () =&gt; &#123;  const count = reactive(    JSON.parse(localStorage.getItem(&#x27;count&#x27;) as string) || []  )  add(value)&#123;      count += value;  &#125;  return &#123;count, add&#125;;&#125;);\n\n六、组件通信1. propssrc/views/Father.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import Child from &#x27;./Child.vue&#x27;;  import &#123;ref&#125; from &#x27;vue&#x27;;    let car = ref(&#x27;宝马&#x27;);  let toy = ref(&#x27;&#x27;);    function getToy(value:string)&#123;    toy.value = value;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h2&gt;父组件&lt;/h2&gt;    &lt;h3&gt;孩子的玩具：&#123;&#123; toy &#125;&#125;&lt;/h3&gt;    &lt;Child :car=&quot;car&quot; :sendToy=&quot;getToy&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/Child.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;    let toy = ref(&#x27;乐高&#x27;);    defineProps([&#x27;car&#x27;,&#x27;sendToy&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h2&gt;子组件&lt;/h2&gt;    &lt;h3&gt;玩具：&#123;&#123; toy &#125;&#125;&lt;/h3&gt;    &lt;h3&gt;礼物：&#123;&#123; car &#125;&#125;&lt;/h3&gt;    &lt;button @click=&quot;sendToy(toy)&quot;&gt;把玩具给父亲&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n\n父组件在创建子组件时，直接在子标签中加属性即可将参数传给子组件，子组件只需用defineProps()方法接收父组件给的参数即可。子组件给父组件传参数，则需要父组件将一函数传给子组件，子组件通过该函数的传参将参数传给父组件。\n\n2. 自定义事件src/views/Father.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import Child from &#x27;./Child.vue&#x27;;  import &#123;ref&#125; from &#x27;vue&#x27;;      let toy = ref(&#x27;&#x27;);    function getToy(value: string) &#123;    toy.value = value;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h2&gt;父组件&lt;/h2&gt;    &lt;h3&gt;孩子的玩具：&#123;&#123; toy &#125;&#125;&lt;/h3&gt;    &lt;Child @send-toy=&quot;getToy&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/Child.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  let toy = ref(&#x27;乐高&#x27;);    const emit = defineEmits([&#x27;sendToy&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h2&gt;子组件&lt;/h2&gt;    &lt;h3&gt;玩具：&#123;&#123; toy &#125;&#125;&lt;/h3&gt;    &lt;button @click=&quot;emit(&#x27;send-toy&#x27;,toy)&quot;&gt;把玩具给父亲&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\n3. mittnpm i mitt\nsrc/utils/emitter.ts:\n// 引入import mitt from &#x27;mitt&#x27;;// 调用const emitter = mitt();// 暴露export defalut emitter;\nsrc/views/Child1.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import emitter from &#x27;@/utils/emitter&#x27;;  let toy = ref(&#x27;乐高&#x27;);  &lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h2&gt;子1组件&lt;/h2&gt;    &lt;h3&gt;玩具：&#123;&#123; toy &#125;&#125;&lt;/h3&gt;    &lt;button @click=&quot;emitter.emit(&#x27;sef-toy&#x27;,toy)&quot;&gt;把玩具给弟弟&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/Child2.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref, onUnmounted&#125; from &#x27;vue&#x27;;  import emitter from &#x27;@/utils/emitter&#x27;;    let computer = ref(&#x27;联想&#x27;);  let toy = ref(&#x27;&#x27;);    emitter.on(&#x27;send-toy&#x27;,(value) =&gt; &#123;    toy.value = value;  &#125;)    onUnmounted(() =&gt; &#123;    emitter.off(&#x27;send-toy&#x27;); // 在该组件卸载时，解绑事件   &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h2&gt;子2组件&lt;/h2&gt;    &lt;h3&gt;电脑：&#123;&#123; computer &#125;&#125;&lt;/h3&gt;    &lt;h3&gt;玩具：&#123;&#123; toy &#125;&#125;&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;\n\n4. v-modelsrc/views/Father.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import ming  let username = ref(&#x27;zhangsan&#x27;);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h2&gt;父组件&lt;/h2&gt;    &lt;!-- v-model用在HTML标签，以下两种写法等效 --&gt;    &lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;    &lt;input type=&quot;text&quot; :value=&quot;username&quot; @input=&quot;username = (&lt;HTMLInputElement&gt;$event.target).value&quot;&gt;    &lt;!-- v-model用在组件标签，以下两种写法等效 --&gt;    &lt;MingInput v-model=&quot;username&quot;/&gt;    &lt;MingInput :modeValue=&quot;username&quot; @update:modeValue=&quot;username = $event&quot;/&gt;    &lt;!-- modeValue值是可以自定义的 --&gt;    &lt;MingInput v-model:xxx=&quot;username&quot;/&gt;    &lt;MingInput :xxx=&quot;username&quot; @update:xxx=&quot;username = $event&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/MingInput.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;    let username = ref(&#x27;zhangsan&#x27;);    defineProps([&#x27;modeValue&#x27;]);  const emit = defineProps([&#x27;update:modeValue&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emit(&#x27;update:modeValue&#x27;,(&lt;HTMLInputElement&gt;$event.target).value)&quot;&gt;&lt;/template&gt;\n5. $attrssrc/views/Father.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import Child from &#x27;./Child.vue&#x27;;  import &#123;ref&#125; from &#x27;vue&#x27;;    let a = ref(1);  let b = ref(2);  let c = ref(3);  let d = ref(4);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;h2&gt;父组件&lt;/h2&gt;    &lt;h4&gt;a:&#123;&#123; a &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;b:&#123;&#123; b &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;c:&#123;&#123; c &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;d:&#123;&#123; d &#125;&#125;&lt;/h4&gt;        &lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x: 100, y: 200&#125;&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/Child.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;  import GrandChild from &#x27;./GrandChild.vue&#x27;;  &lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;child&quot;&gt;    &lt;h2&gt;子组件&lt;/h2&gt;    &lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;  &lt;/div&gt;&lt;/template&gt;\nsrc/views/GrandChild.vue:\n&lt;script setup lang=&quot;ts&quot;&gt;   import &#123;ref&#125; from &#x27;vue&#x27;;    let toy = ref(&#x27;乐高&#x27;);    defineProps([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;x&#x27;, &#x27;y&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;grandChild&quot;&gt;    &lt;h2&gt;孙组件&lt;/h2&gt;    &lt;h4&gt;a:&#123;&#123; a &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;b:&#123;&#123; b &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;c:&#123;&#123; c &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;d:&#123;&#123; d &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;x:&#123;&#123; x &#125;&#125;&lt;/h4&gt;    &lt;h4&gt;y:&#123;&#123; y &#125;&#125;&lt;/h4&gt;  &lt;/div&gt;&lt;/template&gt;\n\n父组件给子组件传的参数，若没有被defineProps()接收，将会以一个对象的形式保存在attrs里,通过$attrs调用该对象。\n\n","categories":["前端"],"tags":["Vue3"]},{"title":"CSS 笔记","url":"/2025/06/01/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/css/","content":"目录\n一、选择器\n二、字体属性\n三、背景属性\n四、文本属性\n五、表格属性\n六、关系选择器\n七、盒子模型\n八、弹性盒子模型\n九、浮动\n十、定位\n十一、CSS3 新特性\n十二、动画\n十三、媒体查询\n十四、CSS Sprite\n十五、字体图标\n\n\n一、选择器\n注：以下 CSS 代码和 HTML 标签不在同一代码块下\n\n1.1 全局选择器* &#123; /* 属性 */ &#125;\n\n作用于所有标签\n\n1.2 元素选择器p &#123; /* 属性 */ &#125;\n\n作用于所有 p 标签\n\n1.3 类选择器.oneclass &#123; /* 属性1 */ &#125;.twoclass &#123; /* 属性2 */ &#125;\n&lt;p class=&quot;oneclass&quot;&gt;属性1生效&lt;/p&gt;&lt;p class=&quot;twoclass&quot;&gt;属性2生效&lt;/p&gt;&lt;p class=&quot;oneclass twoclass&quot;&gt;属性1和属性2都生效&lt;/p&gt;\n\n作用于带特定 class 属性的元素，多个 class 用空格分隔\n\n1.4 ID 选择器#text &#123; /* 属性 */ &#125;\n&lt;p id=&quot;text&quot;&gt;&lt;/p&gt;\n\n作用于唯一的 id 属性元素\n\n1.5 合并选择器p, h3 &#123; /* 属性 */ &#125;.class, #text &#123; /* 属性 */ &#125;\n\n用逗号分隔多个选择器\n\n\n1.6 选择器优先级\n\n\n类型\n权重\n\n\n\n元素选择器\n1\n\n\n类选择器\n10\n\n\nID 选择器\n100\n\n\n内联样式\n1000\n\n\n优先级顺序： 内联 &gt; ID &gt; 类 &gt; 元素\n\n二、字体属性2.1 colorcolor: blue;color: #0000ff;color: rgb(0,0,0);color: rgba(0,0,0,0.5);\n\nrgba() 的 a 表示透明度，范围 0~1\n\n2.2 font-sizefont-size: 12px;\n\n最小支持 12px\n\n2.3 font-weightfont-weight: normal;\n\nnormal 默认（400）bold 粗体（700）bolder 更粗lighter 更细100~900 自定义\n\n2.4 font-stylefont-style: normal;\n\nnormal 默认italic 斜体\n\n2.5 font-familyfont-family: &quot;微软雅黑&quot;;\n\n\n三、背景属性3.1 background-color\n设置背景色，类似 color\n\n3.2 background-imagebackground-image: url(&quot;图片地址&quot;);\n\n3.3 background-repeatbackground-repeat: no-repeat;\n\n图片重复方式：repeat-x 横向重复repeat-y 纵向重复no-repeat 不重复\n\n3.4 background-sizebackground-size: 100% 100%;\n\n设置背景图片大小length 指定数值percentage 百分比cover 保持比例填满容器（可能裁剪）contain 保持比例最大化（不裁剪）\n\n3.5 background-positionbackground-position: left top;\n\n设置图片起始位置，默认 0% 0%常用值：left top、center center、right bottom也可自定义：x% y% 或 xpos ypos\n\n\n四、文本属性4.1 text-align\n文本水平对齐方式：left 左对齐、right 右对齐、center 居中\n\n4.2 text-decoration\n文本修饰：underline 下划线、overline 上划线、line-through 删除线\n\n4.3 text-transform\n控制文本大小写：capitalize 首字母大写、uppercase 全部大写、lowercase 全部小写\n\n4.4 text-indent\n首行缩进，可为负值\n\n\n五、表格属性5.1 bordertable, td &#123; border: 1px solid red; &#125;\n\n边框：大小、线条、颜色\n\n5.2 border-collapse\ncollapse 折叠边框，合并双边框\n\n5.3 width height\n设置表格宽度和高度\n\n5.4 text-align\n表格内文本水平对齐：left、right、center\n\n5.5 vertical-align\n单元格内文本垂直对齐：top、bottom、middle\n\n5.6 padding\n单元格内文本与边框的距离\n\n\n六、关系选择器6.1 后代选择器ul li &#123; /* 属性 */ &#125;\n&lt;ul&gt;    &lt;li&gt;列表1&lt;/li&gt;    &lt;li&gt;列表2&lt;/li&gt;    &lt;li&gt;列表3&lt;/li&gt;&lt;/ul&gt;\n\n选择 ul 内所有 li 标签，语法：E F &#123;&#125;\n\n6.2 子代选择器div &gt; p &#123; /* 属性 */ &#125;\n&lt;div&gt;    &lt;p&gt;选中&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;&lt;p&gt;未选中&lt;/p&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;\n\n选择 div 的直接子元素 p，语法：E &gt; F &#123;&#125;\n\n6.3 相邻兄弟选择器h1 + p &#123; /* 属性 */ &#125;\n&lt;p&gt;未选中&lt;/p&gt;&lt;h1&gt;XXXX&lt;/h1&gt;&lt;p&gt;选中&lt;/p&gt;&lt;p&gt;未选中&lt;/p&gt;\n\n选择紧跟在 h1 后的第一个 p，语法：E + F &#123;&#125;\n\n6.4 通用兄弟选择器h1 ~ p &#123; /* 属性 */ &#125;\n&lt;p&gt;未选中&lt;/p&gt;&lt;h1&gt;XXXX&lt;/h1&gt;&lt;h2&gt;未选中&lt;/h2&gt;&lt;p&gt;选中&lt;/p&gt;&lt;p&gt;选中&lt;/p&gt;\n\n选择 h1 后所有兄弟 p，语法：E ~ F &#123;&#125;\n\n\n七、盒子模型\n所有 HTML 元素都可视为盒子盒模型包括：margin 外边距、border 边框、padding 内边距、content 内容区\n\n\n两个值时，第一个为上下，第二个为左右\n可用 -left、-right、-top、-bottom 单独设置方向\n\n\n八、弹性盒子模型8.1 容器属性\ndisplay: flex 启用弹性盒子布局\nflex-direction 元素排列方向（row&#x2F;row-reverse&#x2F;column&#x2F;column-reverse）\njustify-content 主轴对齐方式（flex-start&#x2F;center&#x2F;space-between 等）\nalign-items 交叉轴对齐方式（flex-start&#x2F;center&#x2F;stretch 等）\n\n8.2 子元素属性\nflex 子元素伸缩比例，设置后宽度不再生效\n\n\n九、浮动9.1 设置浮动\nfloat: left/right/none/inherit  使元素脱离文档流，向左或右浮动\n\n9.2 清除浮动\nclear: left/right/both 控制元素与浮动元素的布局\noverflow: hidden/auto/scroll 创建 BFC，清除浮动影响\n\n9.3 伪元素清除浮动.clearfix::after &#123;    content: &quot;&quot;;    display: block;    clear: both;&#125;\n\n\n十、定位10.1 相对定位position: relative;top: 0;left: 0;\n\n相对于自身原位置偏移，仍占原空间\n\n10.2 绝对定位position: absolute;top: 0;left: 0;\n\n脱离文档流，相对于最近的定位父元素定位\n\n10.3 固定定位position: fixed;top: 0;left: 0;\n\n脱离文档流，固定在浏览器窗口\n\n10.4 堆叠顺序z-index: 1;\n\n控制元素堆叠顺序，仅对定位元素有效\n\n\n十一、CSS3 新特性11.1 圆角border-radius: 10px;\n\n可设置单值、两个值、三个值、四个值或百分比\n\n11.2 阴影box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n\n设置阴影的水平&#x2F;垂直偏移、模糊半径、颜色可设置多个阴影，inset 表示内阴影\n\n11.3 透明度opacity: 0.5;\n\n\n十二、动画12.1 @keyframes 关键帧动画@keyframes animation-name &#123;    0% &#123; background-color: red; &#125;    50% &#123; background-color: blue; &#125;    100% &#123; background-color: red; &#125;&#125;div &#123;    width: 100px;    height: 100px;    background-color: red;    animation: animation-name 2s linear 0s infinite normal;&#125;div:hover &#123;    animation-play-state: paused;&#125;\n\n\nanimation: name duration timing-function delay iteration-count direction;  \n\nname 动画名称  \nduration 持续时间  \ntiming-function 速度曲线（ease、linear、ease-in、ease-out、ease-in-out）  \ndelay 延迟时间  \niteration-count 循环次数  \ndirection 方向（normal、reverse、alternate）\n\n\n\n十三、媒体查询\n根据设备特性应用不同样式\n\n13.1 设置 meta 标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;\n\n13.2 语法@media media-type and (condition) &#123;    /* CSS 规则 */&#125;\n\n13.3 示例@media screen and (max-width: 768px) &#123;    body &#123; background-color: lightblue; &#125;&#125; /* 手机屏幕 */@media screen and (min-width: 769px) and (max-width: 996px) &#123;    body &#123; background-color: lightgreen; &#125;&#125; /* 平板屏幕 */@media screen and (min-width: 997px) &#123;    body &#123; background-color: lightcoral; &#125;&#125; /* 电脑屏幕 */\n\n根据屏幕宽度设置不同背景色\n\n\n十四、CSS Sprite\n将多个图像合并为一个，减少 HTTP 请求，提高加载速度。通过 background-image 和 background-position 显示不同部分。\n\n.sprite &#123;    background-image: url(&#x27;sprite.png&#x27;);    width: 100px;  /* 单个图像宽度 */    height: 100px; /* 单个图像高度 */&#125;.icon1 &#123; background-position: 0 0; &#125;.icon2 &#123; background-position: -100px 0; &#125;.icon3 &#123; background-position: -200px 0; &#125;\n\n.sprite 定义精灵图和尺寸，.icon1、.icon2、.icon3 定位不同图像\n\n\n十五、字体图标&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;\n\n在 &lt;head&gt; 标签中引入 Font Awesome\n\n&lt;i class=&quot;fa fa-camera-retro&quot;&gt;&lt;/i&gt; &lt;!-- 相机图标 --&gt;&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;        &lt;!-- 心形图标 --&gt;&lt;i class=&quot;fa fa-star&quot;&gt;&lt;/i&gt;         &lt;!-- 星形图标 --&gt;\n\n","categories":["学习笔记","前端"],"tags":["CSS"]},{"title":"HTML 笔记","url":"/2025/06/01/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/html/","content":"目录\n目录\n一、标题标签\n二、段落标签\n三、图片标签\n四、超文本链接标签\n五、文本标签\n六、列表标签\n七、表格标签\n八、表单标签\n九、块元素与内联元素\n常见块元素\n常见内联元素\n内联块元素\n\n\n十、容器元素\n\n\n\n\n一、标题标签示例\n&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;\n\n快捷输入：\n\nh1+Tab&#x2F;Enter 自动补全\nh$*6 生成 h1-h6\n\n属性说明：\n\nalign 设置位置：center（默认）、left、right\n\n\n二、段落标签示例\n&lt;p&gt;这是段落&lt;/p&gt;&lt;p&gt;段落中&lt;br /&gt;加换行&lt;/p&gt;&lt;hr color=&quot;&quot; width=&quot;&quot; size=&quot;&quot; align=&quot;&quot;&gt;\n\n快捷输入：\n\np+Tab&#x2F;Enter\nbr+Tab&#x2F;Enter\nhr+Tab&#x2F;Enter\n\n属性说明：\n\n&lt;hr&gt;属性\ncolor 颜色\nwidth 宽度（px 或 %）\nalign 位置：center（默认）、left、right\n\n\n\n\n三、图片标签示例\n&lt;img src=&quot;1.png&quot; alt=&quot;壁纸&quot; width=&quot;300px&quot; height=&quot;200px&quot; title=&quot;壁纸&quot;/&gt;\n\n快捷输入：\n\nimg+Tab&#x2F;Enter\n\n属性说明：\n\nsrc 路径（绝对&#x2F;相对&#x2F;网络）\nalt 图片信息（图片加载异常时显示）\nwidth 宽度\nheight 高度（建议只指定宽度防止比例失调）\ntitle 鼠标悬停提示\n\n\n四、超文本链接标签示例\n&lt;a href=&quot;https://yuanbao.tencent.com/chat/&quot;&gt;里面可以是文本或嵌套图片&lt;/a&gt;\n\n快捷输入：\n\na+Tab&#x2F;Enter\n\n属性说明：\n\nhref 指向网站链接\n\n\n五、文本标签示例\n&lt;em&gt;加重语气+斜体效果&lt;/em&gt;&lt;i&gt;斜体效果&lt;/i&gt;&lt;b&gt;加粗文本&lt;/b&gt;&lt;strong&gt;强调语气+加粗文本&lt;/strong&gt;&lt;span&gt;普通文本&lt;/span&gt;&lt;del&gt;删除的文本&lt;/del&gt;\n\n快捷输入：\n\nem&#x2F;i&#x2F;b&#x2F;strong&#x2F;span&#x2F;del + Tab&#x2F;Enter\n\n\n六、列表标签示例\n&lt;ol type=&quot;1&quot;&gt;\t&lt;li&gt;列表项1&lt;/li&gt;\t&lt;li&gt;列表项2&lt;/li&gt;\t&lt;li&gt;列表项3&lt;/li&gt;\t&lt;li&gt;列表项4&lt;/li&gt;\t&lt;li&gt;列表项5&lt;/li&gt;&lt;/ol&gt;&lt;ul type=&quot;disc&quot;&gt;\t&lt;li&gt;列表项1&lt;/li&gt;\t&lt;li&gt;列表项2&lt;/li&gt;\t&lt;li&gt;列表项3&lt;/li&gt;\t&lt;li&gt;列表项4&lt;/li&gt;\t&lt;li&gt;列表项5&lt;/li&gt;&lt;/ul&gt;\n\n快捷输入：\n\nol&#x2F;ul+Tab&#x2F;Enter\nol&gt;li*5&#x2F;ul&gt;li*5 一键生成列表\n\n属性说明：\n\n&lt;ol&gt; type：1（数字）、a（小写字母）、A（大写字母）、i（小写罗马）、I（大写罗马）\n&lt;ul&gt; type：disc（默认实心圆）、circle（空心圆）、square（小方块）、none（不显示）\n\n\n七、表格标签示例\n&lt;table border=&quot;1px&quot; width=&quot;50%&quot; height=&quot;100%&quot;&gt;\t&lt;tr&gt;\t\t&lt;td&gt;表格单元格1&lt;/td&gt;\t\t&lt;td&gt;表格单元格2&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td&gt;表格单元格3&lt;/td&gt;\t\t&lt;td&gt;表格单元格4&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td&gt;表格单元格5&lt;/td&gt;\t\t&lt;td&gt;表格单元格6&lt;/td&gt;\t&lt;/tr&gt;&lt;/table&gt;&lt;table border=&quot;1px&quot;&gt;\t&lt;tr&gt;\t\t&lt;td colspan=&quot;2&quot;&gt;单元格1和2&lt;/td&gt;\t\t&lt;td rowspan=&quot;2&quot;&gt;单元格3和8&lt;/td&gt;\t\t&lt;td&gt;单元格4&lt;/td&gt;\t\t&lt;td&gt;单元格5&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td&gt;单元格6&lt;/td&gt;\t\t&lt;td&gt;单元格7&lt;/td&gt;\t\t&lt;td&gt;单元格9&lt;/td&gt;\t\t&lt;td&gt;单元格10&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td&gt;单元格11&lt;/td&gt;\t\t&lt;td&gt;单元格12&lt;/td&gt;\t\t&lt;td&gt;单元格13&lt;/td&gt;\t\t&lt;td&gt;单元格14&lt;/td&gt;\t\t&lt;td&gt;单元格15&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;单元格16 17 20 21&lt;/td&gt;\t\t&lt;td&gt;单元格18&lt;/td&gt;\t\t&lt;td&gt;单元格19&lt;/td&gt;\t\t&lt;td&gt;单元格20&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td&gt;单元格23&lt;/td&gt;\t\t&lt;td&gt;单元格24&lt;/td&gt;\t\t&lt;td&gt;单元格25&lt;/td&gt;\t&lt;/tr&gt;&lt;/table&gt;\n\n快捷输入：\n\ntable&#x2F;tr&#x2F;td+Tab&#x2F;Enter\ntable&gt;tr*5&gt;td*5&#123;单元格&#125; 一键生成\n\n属性说明：\n\n&lt;table&gt;\nborder 边框粗细（px&#x2F;%）\nwidth 宽度（px&#x2F;%）\nheight 高度（px&#x2F;%）\n\n\n&lt;td&gt;\ncolspan 向右合并（数字）\nrowspan 向下合并（数字）\n\n\n\n\n八、表单标签示例\n&lt;form action=&quot;&quot; method=&quot;&quot; name=&quot;&quot;&gt;\tusername: &lt;input type=&quot;text&quot;&gt;\t&lt;br /&gt;\tpassword: &lt;input type=&quot;password&quot;&gt;\t&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;\n\n快捷输入：\n\nform&#x2F;input+Tab&#x2F;Enter\n\n属性说明：\n\n&lt;form&gt;\naction 服务器地址（url）\nmethod 方式：get、post\nname 表单名字\n\n\n&lt;input&gt;\ntype：text（文本）、password（密码）、submit（提交）\nvalue 自定义提交按钮文本\n\n\n\n\n九、块元素与内联元素常见块元素独占一行，可设置宽高\n\ndiv、form、h1-6、hr、p、table、ul、ol 等\n\n常见内联元素只占自身大小，不可设置宽高\n\na、b、em、i、span、strong 等\n\n内联块元素不换行，可设置宽高\n\nbutton、img、input\n\n\n十、容器元素用于封装网站结构\n旧版：使用 div 标签\n&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;&lt;div id=&quot;nav&quot;&gt;&lt;/div&gt;&lt;div id=&quot;article&quot;&gt;\t&lt;div id=&quot;section&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;silder&quot;&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\n\n新版：使用语义化标签（利于SEO）\n&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;article&gt;\t&lt;section&gt;&lt;/section&gt;&lt;/article&gt;&lt;aside&gt;&lt;/aside&gt;&lt;footer&gt;&lt;/footer&gt;\n","categories":["学习笔记","前端"],"tags":["HTML"]},{"title":"JavaScript 笔记","url":"/2025/06/01/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/js/","content":"目录一、JavaScript 引入方式二、JavaScript 输出三、数据类型四、typeof 运算符五、补充说明六、字符串七、数组八、对象与内置对象九、DOM 操作十、事件处理操作十一、定时器十二、防抖十三、节流十四、Babel十五、Let十六、Const十七、对象解构赋值十八、字符串拓展十九、字符串新增方法二十、扩展运算符二十一、数组新增方法二十二、对象的拓展二十三、函数拓展二十四、Set 数据结构二十五、Promise 对象二十六、Async 函数二十七、Class二十八、Module\n\n一、JavaScript 引入方式\n推荐在 &lt;body&gt; &lt;/body&gt; 标签内引入\n\n\n嵌入到 HTML\n &lt;script&gt;    // JavaScript 代码    console.log(&quot;Hello, World!&quot;);&lt;/script&gt;\n\n引入本地 JavaScript 文件\n &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;\n\n引入网络 JavaScript 文件\n &lt;script src=&quot;https://example.com/script.js&quot;&gt;&lt;/script&gt;\n\n\n二、JavaScript 输出\nalert()\n alert(&quot;Hello, World!&quot;);\n\n弹出警告框\n\n\nconsole.log()\n console.log(&quot;Hello, World!&quot;);\n\n控制台输出\n\n\ndocument.write()\n document.write(&quot;Hello, World!&quot;);\n\n页面输出（不推荐页面加载后使用）\n\n\n\n\n三、数据类型\n基本数据类型\n\nNumber：数字\nString：字符串\nBoolean：布尔\nUndefined：未定义\nNull：空\nSymbol：唯一值\n\n\n引用数据类型\n\nObject：对象\nArray：数组\nFunction：函数\n\n\n\n\n四、typeof 运算符\n判断数据类型\n\ntypeof 123; // &quot;number&quot;typeof &quot;abc&quot;; // &quot;string&quot;typeof true; // &quot;boolean&quot;typeof &#123;a:1&#125;; // &quot;object&quot;typeof [1,2,3]; // &quot;object&quot;typeof null; // &quot;object&quot;typeof undefined; // &quot;undefined&quot;\n\n\nnull 一般代表对象不存在，undefined 一般代表变量未定义\n\n\n五、补充说明\n比较运算符\n\n=== 和 !==：严格相等&#x2F;不等（不做类型转换）\n== 和 !=：宽松相等&#x2F;不等（会做类型转换）\n\n\nfor in 遍历对象\n\n\nconst myObject = &#123;  name: &quot;Alice&quot;,  age: 30,  city: &quot;New York&quot;&#125;;for (const key in myObject) &#123;  console.log(key + &quot;: &quot; + myObject[key]);&#125;// 输出：// name: Alice// age: 30// city: New York\n\n\n六、字符串1. 引号嵌套与转义\n单引号&#x2F;双引号等价，可互相嵌套\n内部引号需转义 \\\n多行字符串可用 \\ 续行\n\n2. 属性\nlength let str = &quot;Hello, World!&quot;;console.log(str.length); // 13\n\n字符串的长度\n\n\n\n3. 方法\ncharAt()\n  let str = &quot;Hello, World!&quot;;console.log(str.charAt(0)); // H\n\n返回指定位置的字符\n\n  let str = &quot;Hello, World!&quot;;console.log(str.charAt(-1)); // &quot;&quot;\n\n指定值为负数或大于长度时，返回空字符串\n\n\nconcat()\n  let str1 = &quot;Hello&quot;;let str2 = &quot;World&quot;;let str3 = str1.concat(&quot;, &quot;, str2, &quot;!&quot;); // Hello, World!console.log(str3);\n\n连接两个或多个字符串，并返回新的字符串\n\n  let str1 = &quot;Hello&quot;;let str2 = &quot;World&quot;;let str3 = str1 + &quot;, &quot; + str2 + &quot;!&quot;; // Hello, World!console.log(str3);\n\n加号遇到数字类型会进行运算\n\n\nsubstring()\n  let str = &quot;Hello, World!&quot;;console.log(str.substring(0, 5)); // Hello\n\n返回两个指定索引之间的子字符串\n\n  let str = &quot;Hello, World!&quot;;console.log(str.substring(12, 7)); // World\n\n第二个参数小于第一个参数时，自动换位\n\n  let str = &quot;Hello, World!&quot;;console.log(str.substring(7)); // World!\n\n忽略第二个参数时，直到结尾为止\n\n  let str = &quot;Hello, World!&quot;;console.log(str.substring(-1)); // Hello, World!\n\n负数自动转为0\n\n\nsubstr()\n  let str = &quot;Hello, World!&quot;;console.log(str.substr(0, 5)); // Hello\n\n与substring()相似，但第二个参数代表子字符串长度\n\n  let str = &quot;Hello, World!&quot;;console.log(str.substr(7)); // World!\n\n忽略第二个参数时，直到结尾为止\n\n  let str = &quot;Hello, World!&quot;;console.log(str.substr(-6)); // World!\n\n第一个参数负数，则倒数计算位置\n\n  let str = &quot;Hello, World!&quot;;console.log(str.substr(4，-1)); // &quot;&quot;\n\n第二个参数负数，则自动转为0，即返回空字符串\n\n\nindexOf()\n  let str = &quot;Hello, World!&quot;;console.log(str.indexOf(&quot;o&quot;)); // 4\n\n用于确定一个字符在另一个字符中出现的位置，返回值为开始匹配的位置。无法匹配则返回-1\n\n  let str = &quot;Hello, World!&quot;;console.log(str.indexOf(&quot;o&quot;, 5)); // 8\n\n第二个参数为开始匹配的位置\n\n\ntrim()\n  let str = &quot; Hello, World! &quot;;console.log(str.trim()); // Hello, World!\n\n去除字符串两端的空格(去除不仅是空格，还包括换行、制表符等)\n\n  let str = &quot; Hello, World! &quot;;console.log(str.trimStart()); // Hello, World!\n\n  let str = &quot; Hello, World! &quot;;console.log(str.trimEnd()); // Hello, World!\n\ntrimStart() 去除开头空格，trimEnd() 去除结尾空格\n\n\nsplit()\n  let str = &quot;Hello, World!&quot;;console.log(str.split(&quot;, &quot;)); // [&quot;Hello&quot;, &quot;World!&quot;]\n\n按照参数规则将字符串分割成数组\n\n  let str = &quot;Hello, World!&quot;;console.log(str.split(&quot;o&quot;)); // [&quot;Hell&quot;, &quot;, W&quot;, &quot;rld!&quot;]\n\n  let str = &quot;Hello, World!&quot;;console.log(str.split(&quot;&quot;)); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;,&quot;, &quot; &quot;, &quot;W&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]\n\n  let str = &quot;Hello, World!&quot;;console.log(str.split(&quot;&quot; ，4)); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;]\n\n接受第二个参数表示限定返回数组的最大成员数\n\n\n\n\n七、数组1. 定义let arr = [1, 2, 3];let arr2 = [];arr2[0] = &quot;a&quot;;\n2. 属性\nlength  let arr = [1,2,3,4];console.log(arr.length); // 4\n\n数组长度\n\n\n\n3. 方法\nArray.isArray()\n  let arr = [1,2,3,4];console.log(Array.isArray(arr)); // true\n\n判断是否为数组typeof()的局限性，数组返回object，故使用Array.isArray()来判断数组\n\n\npush()\n  let arr = [1,2,3,4];console.log(arr.push(5)); // 5console.log(arr); // [1,2,3,4,5]\n\n在数组末尾添加元素，并返回改变后数组的长度\n\n\npop()\n  let arr = [1,2,3,4];console.log(arr.pop()); // 4console.log(arr); // [1,2,3]\n\n删除数组末尾元素，并返回删除的元素\n\n\nshift()\n  let arr = [1,2,3,4];console.log(arr.shift()); // 1console.log(arr); // [2,3,4]\n\n删除数组开头元素，并返回删除的元素\n\n\nunshift()\n  let arr = [1,2,3,4];console.log(arr.unshift(0)); // 5console.log(arr); // [0,1,2,3,4]\n\n在数组开头添加元素，并返回改变后数组的长度\n\n\njoin()\n  let arr = [1,2,3,4];console.log(arr.join(&#x27;-&#x27;)); // 1-2-3-4\n\n将数组元素连接成字符串与字符串的split()方法互逆\n\n\nconcat()\n  let arr1 = [1,2,3];let arr2 = [4,5,6];let arr3 = arr1.concat(arr2);console.log(arr3); // [1,2,3,4,5,6]\n\n合并数组，返回新数组\n\n  let arr4 = [1];let arr5 = arr4.concat(2，3，4，5);console.log(arr5); // [1,2,3,4,5]\n\nreverse()\n  let arr = [1,2,3,4];console.log(arr.reverse()); // [4,3,2,1]\n\n反转数组注意：该方法会改变原数组\n\n  let str = &#x27;hello&#x27;;let arr = str.split(&#x27;&#x27;);arr.reverse();str = arr.join(&#x27;&#x27;);console.log(str); // &#x27;olleh&#x27;\n\n用于字符串反转\n  let str = &#x27;hello&#x27;;str = str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);console.log(str); // &#x27;olleh&#x27;\n连为一串\n\n\nindexOf()\n  let arr = [1,2,3,4];console.log(arr.indexOf(2)); // 1\n\n返回指定元素在数组中的索引，如果不存在则返回-1\n\n  let arr = [1,2,3,4,2];console.log(arr.indexOf(2)); // 1\n\n只返回第一个匹配项的索引\n\n  let arr = [1,2,3,4,2];console.log(arr.indexOf(2，1)); // 4\n\n第二个参数指定开始搜索的索引\n\n\nmap()\n  let arr = [&quot;Java&quot;, &quot;C&quot;, &quot;Python&quot;];arr.forEach((item, index, array) =&gt; &#123; \tconsole.log( `$&#123;index+1&#125;: $&#123;item&#125; (total： $&#123;array.length&#125;`);&#125;);\n\n用于遍历数组\n\n\n\n\n八、对象与内置对象1. 对象定义let user = &#123;  name: &quot;mingming&quot;,  age: 19,  getName: function() &#123;\tconsole.log(this.name);  &#125;,  container: &#123;\twidth: 100,\theight: 200,\tgetWidth: function() &#123; return this.width; &#125;,\tgetHeight: function() &#123; return this.height; &#125;  &#125;&#125;;\n\n2. Math 对象- `Math.abs(x)`：绝对值\n- `Math.max(a, b, ...)` / `Math.min(a, b, ...)`：最大/最小值\n- `Math.ceil(x)` / `Math.floor(x)` / `Math.round(x)`：向上/下/四舍五入\n- `Math.random()`：0~1 随机数\n\n\nDate 对象\n\nDate.now()：当前时间戳（毫秒）\nnew Date()：当前时间对象\n常用方法：getTime(), getFullYear(), getMonth(), getDate(), getHours(), getMinutes(), getSeconds(), getDay()\n\n\n\n\n九、DOM 操作1. 节点类型\n\n\n节点类型\nnodeType\nnodeName\nnodeValue\n描述\n\n\n\n​​元素节点​​\n1\n大写的标签名 (如 DIV)\nnull\nHTML 元素 (如 &lt;div&gt;)\n\n\n​​属性节点​​\n2\n属性名 (如 id)\n属性值 (如 box)\n元素的属性 (存在于元素的 attributes属性中)\n\n\n​​文本节点​​\n3\n#text\n文本内容\n元素内的文本内容 (包括换行和空格)\n\n\n​​注释节点​​\n8\n#comment\n注释内容\n&lt;!-- comment --&gt;\n\n\n​​文档节点​​\n9\n#document\nnull\n整个文档的入口，即 document对象\n\n\n​​文档类型节点​​\n10\nhtml\nnull\n&lt;!DOCTYPE html&gt;\n\n\n​​文档片段节点​​\n11\n#document-fragment\nnull\n轻量级的文档节点，用于批量操作 [citation:6]\n\n\n示例：\n// 获取元素节点const divElem = document.getElementById(&#x27;myDiv&#x27;);console.log(divElem.nodeType); // 1console.log(divElem.nodeName); // &#x27;DIV&#x27;console.log(divElem.nodeValue); // null// 获取属性节点const idAttr = divElem.getAttributeNode(&#x27;id&#x27;);console.log(idAttr.nodeType); // 2console.log(idAttr.nodeName); // &#x27;id&#x27;console.log(idAttr.nodeValue); // &#x27;myDiv&#x27;// 获取文本节点const textNode = divElem.firstChild;console.log(textNode.nodeType); // 3console.log(textNode.nodeName); // &#x27;#text&#x27;console.log(textNode.nodeValue); // 文本内容\n2. 查询节点\n\n\n方法\n返回内容\n示例\n\n\n\ngetElementById(id)\n匹配 ID 的​​单个元素​​\ndocument.getElementById(&#39;header&#39;)\n\n\ngetElementsByTagName(tag)\n匹配标签名的​​动态​​元素集合 (HTMLCollection)\ndocument.getElementsByTagName(&#39;p&#39;)\n\n\ngetElementsByClassName(class)\n匹配类名的​​动态​​元素集合 (HTMLCollection)\ndocument.getElementsByClassName(&#39;active&#39;)\n\n\nquerySelector(selector)\n匹配 CSS 选择器的​​第一个元素​​\ndocument.querySelector(&#39;.item.highlight&#39;)\n\n\nquerySelectorAll(selector)\n匹配 CSS 选择器的​​静态​​元素集合 (NodeList)\ndocument.querySelectorAll(&#39;ul.menu li&#39;)\n\n\n3. 节点关系\n\n\n属性\n描述\n示例 (假设 elem是一个元素)\n\n\n\nparentNode\n父节点 (可能是元素、文档或文档片段)\nelem.parentNode\n\n\nparentElement\n父​​元素​​节点\nelem.parentElement\n\n\nchildNodes\n所有子节点的集合 (​​包括文本、注释等任何类型的节点​​，NodeList)\nelem.childNodes\n\n\nchildren\n所有​​子元素​​节点的集合 (HTMLCollection)\nelem.children\n\n\nfirstChild&#x2F; lastChild\n第一个&#x2F;最后一个子节点 (​​包括任何类型的节点​​)\nelem.firstChild(可能是文本或换行)\n\n\nfirstElementChild&#x2F; lastElementChild\n第一个&#x2F;最后一个​​子元素​​节点\nelem.firstElementChild\n\n\npreviousSibling&#x2F; nextSibling\n前一个&#x2F;后一个​​兄弟节点​​ (​​包括任何类型的节点​​)\nelem.previousSibling\n\n\npreviousElementSibling&#x2F; nextElementSibling\n前一个&#x2F;后一个​​兄弟元素​​节点\nelem.previousElementSibling\n\n\n4. 节点操作\n创建节点  // 创建新的元素节点const newDiv = document.createElement(&#x27;div&#x27;);// 创建文本节点const newText = document.createTextNode(&#x27;Hello World&#x27;);// 创建文档片段 (用于高效批量操作)const fragment = document.createDocumentFragment();\n插入节点  const parent = document.getElementById(&#x27;parent&#x27;);const newNode = document.createElement(&#x27;div&#x27;);const referenceNode = document.getElementById(&#x27;child2&#x27;);// 作为最后一个子节点插入parent.appendChild(newNode);// 在 referenceNode 之前插入parent.insertBefore(newNode, referenceNode);// 现代方法：直接作为第一个子节点插入parent.prepend(newNode);// 现代方法：插入到元素之后 (非标准，但可用)// parent.appendChild(newNode); 或 parent.insertBefore(newNode, referenceNode.nextSibling);\n修改内容  const elem = document.getElementById(&#x27;myElem&#x27;);// textContent: 获取或设置元素的纯文本内容，包括隐藏内容，性能较好，且能防范XSS攻击elem.textContent = &#x27;New text content&#x27;;// innerHTML: 获取或设置元素的HTML内容（包含标签字符串）elem.innerHTML = &#x27;&lt;strong&gt;Bold&lt;/strong&gt; text&#x27;; // 注意：这会解析HTML字符串，有安全风险// innerText: 获取或设置元素及其后代的“渲染”文本内容（考虑CSS样式，如 visibility: hidden），但性能较差且结果可能因样式而异// elem.innerText = &#x27;Some text&#x27;;\n属性操作  const link = document.querySelector(&#x27;a&#x27;);// 设置属性link.setAttribute(&#x27;href&#x27;, &#x27;https://www.example.com&#x27;);link.setAttribute(&#x27;data-custom&#x27;, &#x27;value&#x27;); // 自定义属性// 获取属性值const hrefValue = link.getAttribute(&#x27;href&#x27;);// 移除属性link.removeAttribute(&#x27;data-custom&#x27;);// 直接通过元素属性访问 (通常用于标准属性，如 id, href, src, value 等)console.log(link.id); // 获取 idlink.id = &#x27;newId&#x27;; // 设置 id\n样式操作  const elem = document.getElementById(&#x27;myElem&#x27;);// 直接操作 style 属性 (修改内联样式，优先级高)elem.style.color = &#x27;red&#x27;;elem.style.backgroundColor = &#x27;#fff&#x27;; // 注意驼峰命名elem.style.marginTop = &#x27;10px&#x27;;// 相较于前者，更简洁elem.style.cssTest = &quot;color:red;backgroudColor:#fff;marginTop:10px&quot;// 使用 classList 操作 CSS 类 (更推荐)gelem.classList.add(&#x27;active&#x27;); // 添加类elem.classList.remove(&#x27;hidden&#x27;); // 移除类elem.classList.toggle(&#x27;visible&#x27;); // 切换类（有则删，无则加）elem.classList.contains(&#x27;active&#x27;); // 检查是否包含某个类\n删除节点  const elemToRemove = document.getElementById(&#x27;to-remove&#x27;);// 现代方法：直接调用元素自身的 remove()elemToRemove.remove();// 传统方法：通过父节点删除子节点const parent = elemToRemove.parentNode;parent.removeChild(elemToRemove);\n其他常用操作  // 克隆节点const original = document.getElementById(&#x27;original&#x27;);const clone = original.cloneNode(true); // 参数 true 表示深度克隆（包括所有子节点）// 替换节点const oldNode = document.getElementById(&#x27;old&#x27;);const newNode = document.createElement(&#x27;div&#x27;);newNode.textContent = &#x27;Replacement&#x27;;oldNode.parentNode.replaceChild(newNode, oldNode);// 检查是否有子节点const hasChildren = parentElement.hasChildNodes();\n\n\n十、事件处理操作1.添加事件\nHTML事件  &lt;button onclick=&quot;clickHandle()&quot;&gt;按钮&lt;/button&gt;&lt;script&gt;  function clickHandle()&#123;\tconsole.log(&quot;点击了按钮&quot;);  &#125;&lt;/script&gt;\n\n缺点：js和html未分离\n\n\nDOM0事件  &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;script&gt;  var btn = document.getElementById(&quot;btn&quot;);  btn.onclick = function()&#123;\tconsole.log(&quot;点击了按钮1&quot;);  &#125;   btn.onclick = function()&#123;\tconsole.log(&quot;点击了按钮2&quot;);  &#125;   //只会输出2，1被覆盖&lt;/script&gt;\n\n优点：js和html分离 缺点：无法同时添加多个事件\n\n\nDOM2事件  &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;script&gt;  var btn = document.getElementById(&quot;btn&quot;);  btn.addEventListener(&quot;click&quot;, function()&#123;\tconsole.log(&quot;点击了按钮1&quot;);  &#125;)  btn.addEventListener(&quot;click&quot;, function()&#123;\tconsole.log(&quot;点击了按钮2&quot;);  &#125;)  //1和2都会输出&lt;/script&gt;\n\n优点：可同时添加多个事件 缺点：麻烦\n\n\n\n2.事件类型鼠标\n\n\n事件\n解释\n\n\n\nclick\n按下鼠标时触发\n\n\ndbclick\n双击鼠标时触发\n\n\nmousedown\n按下鼠标键是触发\n\n\nmouseup\n释放鼠标键时触发\n\n\nmousemove\n鼠标在节点内移到时触发，持续移动连续触发\n\n\nmouseenter\n鼠标进入节点时触发，进入子节点不触发\n\n\nmouseleave\n鼠标离开节点时触发，离开父节点不触发\n\n\nmouseover\n鼠标进入节点时触发，进入子节点再触发\n\n\nmouseout\n鼠标离开节点时触发，离开父节点再触发\n\n\nwheel\n滚动滚轮时触发\n\n\n表单\n\n\n事件\n解释\n\n\n\ninput\n输入时触发\n\n\nselect\n选中时触发\n\n\nChange\n回车或失去焦点触发\n\n\n\n\n\n方法\n解释\n\n\n\nreset\n重置表单\n\n\nsubmit\n提交表单\n\n\n3.Event 事件对象&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;script&gt;\tvar btn = document.getElementById(&quot;btn&quot;);\t\tbtn.onclick = function(event)&#123;\t\tconsole.log(event);\t&#125; \t// function(e) 简写&lt;/script&gt;\n属性\nEvent.target  &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;script&gt;  var btn = document.getElementById(&quot;btn&quot;);  btn.onclick = function(event)&#123;\tevent.target.innerHTML = &quot;点击后&quot;;  &#125; //点击后button文本由 “按钮” 变 “点击后”&lt;/script&gt;\nEvent.type  &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;&lt;script&gt;  var btn = document.getElementById(&quot;btn&quot;);  btn.onclick = function(event)&#123;\tconsole.log(event.type); // click  &#125; &lt;/script&gt;\n\n方法\nEvent.preventDefault()  &lt;a href=&quot;www.baidu,com&quot; id=&quot;a&quot;&gt;百度&lt;/a&gt;&lt;script&gt;  var a = document.getElementById(&quot;a&quot;);  a.onclick = function(event)&#123;\tevent.preventDefault(); //阻止默认事件，此时点击并不会跳转\tconsole.log(&quot;点击了a标签&quot;) ;  &#125; &lt;/script&gt;\nEvent.stopPropagation()  .root&#123;  width: 200px;  height: 200px;  background-color: red;&#125;.box&#123;  width: 100px;  height: 100px;  background-color: blue;&#125;\n  &lt;div class = &quot;root&quot; id = &quot;root&quot;&gt;  &lt;div class = &quot;box&quot; id = &quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;  var root = document.getElementById(&quot;root&quot;);  var box = document.getElementById(&quot;box&quot;);\t  root.onclick = function()&#123;\tconsole.log(&quot;点击了root&quot;);  &#125;   box.onclick = function(e)&#123;\te.stopPropagation();//阻止事件冒泡，此时点击仅触发box的点击事件\tconsole.log(&quot;点击了box&quot;);  &#125; \t&lt;/script&gt;\n\n4. 事件代理\n基于事件冒泡的原理，通过父元素的代理，集中处理子元素的事件逻辑\n\n&lt;ul id = &quot;list&quot;&gt;  &lt;li&gt;1&lt;/li&gt;  &lt;li&gt;2&lt;/li&gt;  &lt;li&gt;3&lt;/li&gt;  &lt;li&gt;4&lt;/li&gt;  &lt;p&gt;段落&lt;/p&gt;&lt;/ul&gt;&lt;script&gt;  var list = document.getElementById(&quot;list&quot;);  list.addEventListener(&quot;click&quot;,function(e)&#123;\tif(e.target.tagName === &quot;LI&quot;)&#123;\t  console.log(e.target.innerHTML);\t&#125;\t// tagName默认是大写，可以使用`toLowerCase()`方法转小写；  &#125;)&lt;/script&gt;\n\n十一、定时器\nsetTimeout()\n\n指定某个函数或某段代码，在多少毫秒后执行\n\n  setTimeout(function()&#123;  console.log(&quot;定时器&quot;);&#125;,1000);\n\n注意：如果回调函数时对象方法，那么setTimeout()使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象\n\n  var name = &quot;a&quot;;var user = &#123;  name: &quot;b&quot;,  getName: function()&#123;\tsetTimeout(function()&#123;\t  console.log(this.name);\t&#125;,1000)  &#125;&#125;;user.getName();//this指向全局作用域，此处输出a\n\n解决办法\n\n  var name = &quot;a&quot;;var user = &#123;  name: &quot;b&quot;,  getName: function()&#123;\tvar that = this;\tsetTimeout(function()&#123;\t  console.log(that.name);\t&#125;,1000)  &#125;&#125;;user.getName();// b\n\n定时器可以取消\n\n  var id = setTimeout(f,1000);clearTimeout(id);\nsetINterval()\n  var timer = setInterval(function()&#123;console.log(2);&#125;,1000);\n\n每隔一段时间执行一次\n\n\n\n十二、防抖\n让高频触发的事件在短时间内只触发一次事件（例如滚动事件）原理：在delay时间内若持续触发事件，则不断重置延时函数。只有在delay时间内不触发事件延时函数才能正常执行。（手机固定时间熄屏逻辑）\n\nfunction debounce(fn,delay)&#123;  var timer = null;  return function()&#123;\tif(timer)&#123;\t  clearTimeout(timer);\t&#125;\ttimer = setTimeout(fn,delay);  &#125;&#125;window.onscroll = debounce(scrollHandle,200);function scrollHandle()&#123;  var scrollTop = document.documentElement.scrollTop;  console.log(scrollTop);&#125;\n十三、节流\n让高频触发的事件在一定间隔触发一次，达到节约流量的效果。原理：在valid为真时触发事件，并反转valid状态，等延时函数触发时再让valid恢复为真（搜索框联想逻辑）\n\nfunction throttle(fn,delay)&#123;  var valid = true;  return function()&#123;\tif(!valid)&#123;\t  return false;\t&#125;\tvalid = false;\tsetTineout(function()&#123;\t  fn();\t  valid = true;\t&#125;,delay);  &#125;&#125;window.onscroll = throttle(scrollHandle,2000);function scrollHandle()&#123;  var scrollTop = document.documentElement.scrollTop;  console.log(scrollTop);&#125;\n十四、Babel1. 安装Babelnpm install --save-dev @babel/core\n2. 配置文件 .babelrc&#123;  &quot;presets&quot;: [],  &quot;plugins&quot;: []&#125;\n3. 转码规则npm install --save-dev @babel/preset-env\n4. 将规则加入&#123;  &quot;presets&quot;: [\t&quot;@babel/env&quot;  ],  &quot;plugins&quot;: []&#125;\n5. Babel命令行转码工具npm install --save-dev @babel/cli\n基本用法\n# 转码结果输出到标准输出npx babel example.js#转码结果写入文件npx babel example.js -o complied.js# 或者npx babel example.js -out-file complied.js# 整个目录转码npx babel src --out-dir lib# 或者npx babel src -d lib\n十五、Let\n1.var关键字：函数级作用域2.let关键字：\t1.let是块级作用域\t2.let不存在变量提升\t3.let不允许重复声明\n\n十六、Const\nconst关键字：\t1.声明之后不可改变\t2.声明时必须初始化\t3.块级作用域\t4.不存在变量提升\t5.不能重复声明\n\n十七、对象解构赋值user = &#123;  name: xxx,  age: 20&#125;const &#123; name, age &#125; = user;console.log(name, age);const &#123; log &#125; = console;log(name, age);\n十八、字符串拓展1. 字符串Unicode表示法console.log(&quot;\\u0061&quot;);// &quot;a&quot;\n2. 字符串遍历接口var str = &quot;hello&quot;;for(let i of str)&#123;\tconsole.log(i);&#125;//h e l l o\n3. 模板字符串var href = &quot;https://www.baidu.com&quot;;var text = &quot;百度&quot;var baidu = `&lt;a href = &quot;$(href)&quot;&gt;$(text)&lt;/a&gt;`;\n十九、字符串新增方法\nincludes() startsWith() endWith() let str = &quot;Hello&quot;;str.includes(&quot;ell&quot;);// truestr.starWith(&quot;He&quot;);// truestr.endWith(&quot;lo&quot;);// truelet s = &quot;hello world!&quot;s.includes(&quot;hello&quot;, 6)// false 从索引6开始，是否包含&quot;hello&quot;s.starWith(&quot;world&quot;, 6);// true 从索引6开始，是否以&quot;world&quot;开始s.endWith(&quot;hello&quot;, 5);// true 到索引5结束，是否以&quot;hello&quot;结束\nrepeat() let x = &quot;x&quot;;console.log(x.repeat(3));// &quot;xxx&quot;console.log(x);// &quot;x&quot;\npadStart() padEnd() let x = &quot;x&quot;;x.padStart(5, &quot;01&quot;);// &quot;0101x&quot;x.padStart(4, &quot;01&quot;);// &quot;010x&quot;x.padEnd(5, &quot;01&quot;);// &quot;x0101&quot;x.padEnd(4, &quot;01&quot;);// &quot;x010&quot;\ntrimStart() trimEnd() const s = &quot;  xxx  &quot;;s.trim();// ”xxx“s.trimStart();// &quot;xxx  &quot;s.trimEnd();// &quot;  xxx&quot;\nat() let s = &quot;abcdefg&quot;;console.log(s.at(3));// d, 输出索引为3的字符console.log(s.at(-3));// e, 输出索引为-3的字符\n\n二十、扩展运算符扩展运算符（…）。将一个数组转为用逗号分隔的参数序列\nconsole.log(...[1, 2, 3]);// 1 2 3console.log(1, ...[2, 3, 4], 5);// 1 2 3 4 5\n可以代替apply方法\nlet arr = [10, 20, 30, 40];//ES5console.log(Math.max.apply(null, arr));// 40//ES6console.log(Math.max(...arr));// 40\n合并数组\nlet arr1 = [1, 2, 3, 4];let arr2 = [5, 6, 7, 8];//ES5console.log(arr1.concat(arr2));//ES6console.log([...arr1, ...arr2]);\n二十一、数组新增方法\nArray.form()\n\n用于将类数组转化为数组\n\n 常见的类数组\n\narguments\narguments只能使用数组的读取方式和length属性，不能使用数组方法\n  function add()&#123;  console.log(arguments);// Arguments(3)[10, 20, 30, callee: f, Symbol(Symbol.iterator): f]\t  console.log(arguments[0]);// 10  console.log(arguments[1]);// 20  console.log(arguments[2]);// 30\t  console.log(Array.form(arguments));// (3) [10, 20, 30]&#125;add(10, 20, 30);\n\n元素集合  &lt;body&gt;  &lt;h1&gt;1&lt;/h1&gt;  &lt;h1&gt;2&lt;/h1&gt;  &lt;h1&gt;3&lt;/h1&gt;  &lt;script&gt;\tlet titles = document.querySelectorAll(&quot;h1&quot;);\tconsole.log(titles);// NodelList(3) [h1, h1, h1]\tconsole.log(Array.form(titles));// (3) [h1, h1, h1]  &lt;/script&gt;&lt;/body&gt;\n类似数组的对象  let user = &#123;  &quot;0&quot;: xxx,  &quot;1&quot;: 20,  &quot;2&quot;: &quot;man&quot;,  length: 3&#125;console.log(user);// &#123;0: &#x27;xxx&#x27;, 1: 20, 2: &#x27;man&#x27;, length: 3&#125;console.log(Array.form(user));// (3) [&#x27;xxx&#x27;, &#x27;20&#x27;, &#x27;man&#x27;]\n\n\nArray.of()\n Array.of(10, 20, 30);// [10, 20, 30]\n\n将一组值转化为数组\n\n\n\n二十二、对象的拓展1. 属性的简洁表示//ES5let name = &quot;xxx&quot;;let user = &#123;  name: name,  age: 20  getName:function()&#123;\tconsole.log(this.name);  &#125;&#125;console.log(user.name);// &quot;xxx&quot;user.getName();// &quot;xxx&quot;//ES6let name = &quot;xxx&quot;;let user = &#123;  name,// 属性名和属性值相同名称的时候可以省略  age: 20  getName()&#123;\tconsole.log(this.name);  &#125;&#125;console.log(user.name);// &quot;xxx&quot;user.getName();// &quot;xxx&quot;\n2. 属性名表达式//ES5let user = &#123;  baidu: &quot;web&quot;,  age: 13&#125;//ES6let propKey = &#x27;baidu&#x27;;let user = &#123;  [propKey]: &quot;web&quot;,  age: 13&#125;\t\n3. 对象的拓展运算符let z = &#123; a: 1, b: 2 &#125;;let n = &#123; ...z, z &#125;;console.log(n);// &#123; a: 1, b: 2, &#123;...&#125;&#125;\n\n二十三、函数拓展1. 箭头函数// 直接声明函数function fn1(x, y)&#123;  return x + y;&#125;// 赋值型声明函数let fn2 = function(x, y)&#123;  return x + y;&#125;// 箭头函数let fn3 = () =&gt; 10;let fn4 = x =&gt; x+1;let fn5 = (x, y) =&gt; x+y;let fn6 = (x, n) =&gt; &#123;  for (let i = 1; i&lt;=n; i++)&#123;\tx*=x;  &#125;  return x;&#125;let fn7 = (x, y) =&gt; (&#123;x: 10, y: 20&#125;);// 若返回对象，需要加一层括号避免歧义\n将匿名函数改写为箭头函数\nlet arr = [1, 2, 3];arr.map(function(element, index)&#123;  console.log(element);&#125;)arr.map((element, index) =&gt; &#123;console.log(element);&#125;)\n对普通函数内部的this指向函数运行时的对象，但这点对箭头函数不成立。它没有自己的this,内部的this就是定义时上层作用域的this\nvar name = &quot;a&quot;;var user = &#123;  name: &quot;b&quot;,  getName()&#123;\tsetTimeout(function()&#123;\t  console.log(this.name);\t&#125;,1000)  &#125;&#125;;user.getName();//this指向全局作用域，此处输出a\n使用箭头函数可以避免该问题\nvar name = &quot;a&quot;;var user = &#123;name: &quot;b&quot;,getName()&#123;  setTimeout(() =&gt; &#123;\t  console.log(this.name);\t&#125;,1000)  &#125;&#125;;user.getName();//this指向箭头函数上层作用域，此处输出b\n二十四、Set 数据结构1. 定义类似于数组，但成员值都是唯一的，没有重复值。Set()本身是一个构造函数，用于生成Set数据结构。\nlet s = new Set();let arr = [1, 2, 3, 3, 4, 5];arr.forEach(x =&gt; s.add(x));console.log(s);// (5)[1, 2, 3, 4, 5]let set = new Set([1, 2, 3, 4]);// Set()构造函数可以接受数组作为参数\n数组去重\nlet arr = [10, 20, 30, 10, 20, 40];console.log([...new Set(arr)]);// [10, 20, 30, 40]\n字符串去重\nlet str = &quot;abcabcabb&quot;;console.log([...new Set(str)].join(&#x27;&#x27;));// &quot;abc&quot;\n向set类型添加数据时不会发生字符转换\nlet set = new Set();set.add(5);set.add(&quot;5&quot;);console.log(set);// Set(2) &#123;5, &#x27;5&#x27;&#125;\n2. 属性\nsize  const s = new Set([1, 2, 3, 4, 4, 4]);console.log(s.size);// 4\n\n返回成员数\n\n\n\n3. 方法\nadd()\n向set中添加数据\n\n\ndelete()\n删除数据\n\n\nhas()\n判断是否含有\n\n\nclear()\n清空\n\n\n\n二十五、Promise 对象1. 定义一种异步编程的解决方案\n2. 用法ES6规定，Promise是一个构造函数，用来生成Promise实例\nconst promise = new Promise(function(resolve, reject)&#123;  // 异步代码  if(/* 异步操作成功 */)&#123;\tresolve(value);  &#125;else&#123;\treject(error);  &#125;&#125;)\nPromise实例生成后，可以用then方法分别指定resolve状态和reject状态的回调函数\npromise.then(function(value)&#123;  // sucess&#125;,function(error)&#123;  //failure&#125;);\n二十六、Async 函数1. 定义ES6引入async函数，使异步操作更简单。可以将异步操作变为同步操作\n2. 用法function print()&#123;  setTimeout(() =&gt; &#123;\tconsole.log(&quot;定时器&quot;);  &#125;,10)  console.log(&quot;Hello&quot;);&#125;print();// Hello 定时器\n使用async将上述异步改同步\nfunction timeout(ms)&#123;  return new Promise((resolve, reject) =&gt;&#123;\tsetTimeout(() =&gt; &#123;\t  console.log(&quot;定时器&quot;)\t  resolve();\t&#125;, ms);\t  &#125;);&#125;async function asyncPrint(ms, value)&#123;  await timeout(ms);  console.log(value);&#125;asyncPrint(100, &quot;hello&quot;);\n二十七、 Class1. 基本语法// ES5function Preson(name, age)&#123;  this.name = name;  this.age = age;&#125;Person.prototype.getName = function()&#123;  console.log(this.name);&#125;let p = new Person(&quot;xxx&quot;, 20);p.getName();// ES6class Person&#123;  constructor(name, age)&#123;\tthis.name = name;\tthis.age = age;  &#125;  getName()&#123;\tconsole.log(this.name);  &#125;&#125;let p = new Person(&quot;xxx&quot;, 20);p.getName();\n\nclass不存在提升\n\n2. 属性与方法class Person&#123;\t// 实例属性  constructor(name, age)&#123;\tthis.name = name;\tthis.age = age  &#125;\t// 静态属性  static age = 100;\t\t// 实例方法  getName()&#123;\tconsole.log(this.name);  &#125;\t\t// 静态方法  static say()&#123;\tconsole.log(&quot;hi&quot;);\tconsole.log(this.name);// 静态方法指向当前类，非实例对象  &#125;\t// 静态方法和实例方法可同名  say()&#123;\tconsole.log(&quot;hii&quot;);\tconsole.log(this.name);  &#125;\t&#125;// 实例对象let p = new Person(&quot;xxx&quot;, 20);p.getName();Person.say();// 调用静态方法用类名调用\n3. 继承class Person&#123;  constructor(name, age)&#123;\tthis.name = name;\tthis.age = age  &#125;  getName()&#123;\tconsole.log(this.name);  &#125;  static say()&#123;\tconsole.log(&quot;hi&quot;);  &#125;&#125;// 用extends继承父类class Student extends Person&#123;  constructor(name, age, scoolName)&#123;    super(name, age);// 子类constructor方法必须调用super()\tthis.schoolName = schoolName;  &#125;&#125;let s = new Person(&quot;xx&quot;, 20, &quot;No.1&quot;);s.getName();// xxStudent.say();// hi\n二十八、 Module1. 导入导出// ES6// 1.jsexport var hello = &quot;Hello&quot;;// 将变量导出// 2.jsimport &#123; hello &#125; from &quot;./1&quot;;// 将变量导入console.log(hello);\n2. 改名// 1.jsexport var hello = &quot;Hello&quot;;// 2.jslet hello = &quot;HelloWorld!&quot;import &#123; hello as hi &#125; from &quot;./1&quot;;console.log(hi);// Helloconsole.log(hello);// HelloWorld!\n3. 整体导入// hello.jsexport var hello = &quot;Hello&quot;;export say = () =&gt; console.log(&quot;Hi&quot;);// index.jsimport * as helloJs from &quot;./hello&quot;;// 将指定js的全部导出导入到对象helloJs.say();// Hiconsole.log(helloJs.hello);// Hello\n4. 默认导出// 1.jsexport default function()&#123;  console.log(&quot;hi&quot;);&#125;// 默认导出// 2.jsimport say from &quot;./1&quot;;// 将默认导出导入到say中say();// hi\n","categories":["学习笔记","前端"],"tags":["JavaScript"]},{"title":"TypeScript 笔记","url":"/2025/09/14/%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/ts/","content":"一、编译1. 命令行编译\n第一步： 创建.ts文件\n第二步： 全局安装TypeScript  npm install -g typescript\n第三步： 使用命令行编译  tsc example.ts\n\n2. 自动化编译\n第一步： 创建TypeScript编译配置文件  tsc --init\n第二步： 监视目录的.ts变化  tsc --watch\n第三步： 小优化   tsc --noEmitOnError --watch\n\n二、类型声明let a: string = &quot;abc&quot;;let b: number = 91;let c: boolean = true;function count(x: number, y: number): number&#123;  return x + y;&#125;\n三、类型推断let a = 123;a = &quot;abc&quot;// 报错！！！\n四、类型总览1. JavaScript 中的数据类型\nstring\nnumber\nboolean\nnull\nundefined\nbigint\nsymbol\nobject\nobject包含：Array，Function，Date，Error等…\n\n\n\n2. JavaScript 中的数据类型\n上述所有类型\n六个新类型\n&#96;any\nunknown\nnever\nvoid\ntuple\nenum\n\n\n两个用于自定义类型的方式\ntype\ninterface\n\n\n\n3. 注意\n在JavaScript和TypeScript中内置构造函数：Number，String，Boolean可用于创建包装对象，日常开发少用，通常使用小写的类型\n\n五、常用类型1. any// 显式anylet a: any;a = 91;a = &quot;abc&quot;;a = true;// 隐式anylet b;b = 91;b = &quot;abc&quot;;b = true;\n\nany类型不进行类型检查\n\nlet c = true;let d: string = c;console.log(d);// true;\n\nany类型可赋值给任何类型\n\n2. unknownlet a: unknown;let b: string;a = 91;a = &quot;abc&quot;;a = true;b= a;// 报错！！！a = &quot;abc&quot;;b = a;// 报错！！！// 第一种方式if(typeof a === &#x27;string&#x27;)&#123;  b = a;// 正常赋值&#125;// 第二种方式（断言）x = a as string;// 第三种方式（断言）x = &lt;string&gt;a;\n\nunknown与any相似，但是不能直接赋值给其他变量，即便类型是相同的 \n\nlet a: string = &#x27;hi&#x27;;a.toUpperCase();// 无警告let a: any = &#x27;hi&#x27;;a.toUpperCase();// 无警告let a: unknown = &#x27;hi&#x27;;a.toUpperCase();// 报错！！！(a as string).toUpperCase();&lt;string&gt;a.toUpperCase();\n\nunknown调用任何属性方法都会报错，与any恰恰相反\n\n3. never1. 几乎不用never限制变量，没有意义2. 可用于限制函数。返回never的函数不能有可访问的终节点function test() : nerver &#123;&#125;// 报错，函数没return，默认返回undefined类型// 情况一function test() : nerver &#123;\ttest()&#125;// 函数无限运行，不会返回值，无警告// 情况二function test() : nerver &#123;\tthrow new Error(&quot;异常&quot;);&#125;// 函数报错，直接结束调用，没有返回值，无警告\n3. never一般为TypeScript主动推断出来的let a: string = &quot;abc&quot;;if(a === &#x27;string&#x27;) &#123;  console.log(a.toUpperCase());&#125;else&#123;  console.log(a);// TypeScript推断此处a为never，因为没有任何一个值符合该情况&#125;\n4. voidvoid通常用于函数返回值声明，含义：函数返回空（undefined），调用者也不应依赖返回值进行任何操作\nfunction logMessage(msg: string) : void &#123;  console.log(msg);&#125;// return除了undefined的类型都会报错（any因其独特的机制也可以返回）// 三种返回方式：return undefined; return; (啥也不写，隐式返回undefined)logMessage(&quot;hi&quot;);\n\nfunction test1() : void &#123;&#125;let result1 = test1();console.log(result1);// undefinedif(result1)&#123;&#125;// 报错，不应该用void1的返回值进行操作function test2() : undefined &#123;&#125;let result2 = test2();if(result2)&#123;&#125;// 无警告\n\n5. object1. object和Object项目不常用\nobject不能存原始类型（number, boolean, string, null, undefined）只能存非原始类型\nObject能存储可以调用到Object方法的类型（除了null和undefined）\n\n2. 声明对象类型1. 常用以下形式// 三种方式，?表示可选属性let Person = &#123; name: string, age?: number &#125;let Person = &#123; name: string; age?: number &#125;let Person = &#123;  name: string  age?: number&#125;\n2. 索引签名// 三种方式，?表示可选属性let Person = &#123;  name: string  age?: number  [key: string]: any// 可以在对象上加任何属性，key改为任何变量名都没问题&#125;Person = &#123; name: &quot;xxx&quot;, age: 20, city: &quot;Beijin&quot;&#125;\n3. 声明函数类型let count: (a: number, b: number) =&gt; numbercount = function (x, y) &#123;  return x + y;&#125;\n\nTypeScript中的=&gt;在函数声明时表示函数类型，描述其参数类型和返回类型JavaScript中的=&gt;表示箭头函数\n\n4. 声明数组类型let arr1: string[];let arr2: Array&lt;number&gt;;arr1 = [&#x27;a&#x27;, &#x27;b&#x27;];arr2 = [12, 34];\n\n6. tuple元组是一种特殊的数组类型，可以存储固定数量的元素，并且每个元素的类型是已知的且可以不同，元组用于精确描述一组值的类型，?表示可选元素，...表示任意多个。\nlet a: [string, number];let b: [string, boolean?];let c: [string, ...string[]];\n7. enum1. 数字枚举enum Direction &#123;  Up,  Down,  Left,  Right&#125;function walk(data: Direction) &#123;  if(data === Direction.Up)&#123;\tconsole.log(&quot;向上走&quot;);  &#125;  if(data === Direction.Down)&#123;\tconsole.log(&quot;向下走&quot;);  &#125;  if(data === Direction.Left)&#123;\tconsole.log(&quot;向左走&quot;);  &#125;  if(data === Direction.Right)&#123;\tconsole.log(&quot;向右走&quot;);  &#125;&#125;Walk(Direction.Up);\n\n成员值自动递增，且数字还具备反向映射的特点。\n\n2. 字符串枚举enum Direction &#123;  Up = &quot;up&quot;,  Down = &quot;down&quot;,  Left = &quot;left&quot;,  Right = &quot;right&quot;&#125;let dir: Direction = Direction.Up;console.log(dir);// &quot;UP&quot;\n3. 常量枚举const enum Direction &#123;  Up,  Down,  Left,  Right&#125;console.log(Direction.Up);\n\n常量枚举使用const关键字定义，在编译时会被内联，避免生成额外代码编译时内联：TypeScript在编译时，会枚举成员引用替换为它的实际值而不是生成额外的枚举对象。可以减少JavaScript代码量，提高运行效率。\n\n8. type1. 基本用法type shuzi = number;ket a: shuzi;\n2. 联合类型type Status = number | string;type Gender = &#x27;男&#x27; | &#x27;女&#x27;;function printStatus(data: Status): void&#123;  console.log(data)&#125;\n3. 交叉类型type Area = &#123;  height: number  width: numer&#125;;type Address = &#123;  num: number  cell: number  room: string&#125;;type House = Area &amp; Address;const house: House = &#123;  height: 100,  weight: 100,  num: 1,  cel: 2,  room: &#x27;702&#x27;&#125;\n9. 一种特殊情况function demo(): void&#123;  return undefined;  // 以下均不合法  return 100;  return false;  return null;  return [];&#125;\n\ntype LogFunc = () =&gt; void;\tconst f1: LogFunc = function() &#123;  // 以下均合法  return undefined;  return 100;  return false;  return null;  return [];&#125;;\nconst src = [1, 2, 3];const dst = [0];src.forEach((e1) =&gt; dst.push(e1))\n\nforEach()的期望返回值是void，而push()的返回值是number。为了使类似的代码成立，而做了取舍\n\n11. 类class Person &#123;  name: string;  age: number;  constructor(name: string, age: number)&#123;\tthis.name = name;\tthis.age = age;  &#125;  speak() &#123;\tconsole.log(`名字：$&#123;this.name&#125;，年龄：$&#123;this.age&#125;`);  &#125;&#125;class Student extends Person &#123;  grade: string;  constructor(name: string, age: number, grade: string)&#123;\tsuper(name, age);\tthis.grade = grade;  &#125;  study()&#123;\tconsole.log(`$&#123;this.name&#125;，正在学习`);  &#125;  override speak() &#123;\tconsole.log(`我的名字：$&#123;this.name&#125;，我的年龄：$&#123;this.age&#125;`);  &#125;&#125;\n12. 属性修饰符\n\n\n修饰符\n含义\n具体规则\n\n\n\npublic\n公开的\n可以被：类内部，子类，类外部访问\n\n\nprotected\n受保护的\n可以被：类内部，子类访问\n\n\nprivate\n私有的\n可以被：类内部访问\n\n\nreadonly\n只读属性\n属性无法修改\n\n\n// 简写前class Person &#123;  name: string;  age: number;constructor(name: string, age: number)&#123;\tthis.name = name;\tthis.age = age;&#125;   this.name = name;    this.age = age;  &#125;&#125;// 简写后class Person &#123;  constructor(public name: string, public age: number) &#123;&#125;&#125;\n12. 抽象类抽象类无法实例化，意义在于可以被继承，抽象类里可以有普通方法，也可以有抽象方法\nabstract class Package &#123;  // 构造方法  constructer(public weight: number) &#123;&#125;  // 抽象方法  abstract calculate(): number  // 具体方法  printPackage() &#123;    console.log(&quot;xxxx&quot;);  &#125;&#125;class StandardPackage extends Package &#123;  constructor(    weight: number,    public uniPrice: number  ) &#123; super(weight) &#125;  calculate(): number&#123;    return this.weight * this.unitPrice;  &#125;&#125;\n13. interface接口为类，对象，函数等规定一种契约，确保代码一致性和类型安全。只能定义格式，不能包含任何实现\n1. 定义类结构interface PersonInterface &#123;  name: string;  age: number;  speak(n: number): void&#125;class Person implements PersonInterface &#123;  constructor(    public name: string,    public age: number  ) &#123;&#125;  speak(n: number): void &#123;\tfor (let i = 0; i &lt; n; i++) &#123;      console.log(&#x27;xxxx&#x27;)\t&#125;  &#125;&#125;\n\n2. 定义对象结构interface UserInterface &#123;  name: string;  readonly gender: string;  age?: number;  run: (n: number) =&gt; void;&#125;const user: UserInterface = &#123;  name: &quot;zhangsan&quot;,  gender: &quot;男&quot;,  age: 18,  run(n) &#123;\t  console.log(&quot;xxx&quot;)  &#125;&#125;\n3. 定义函数结构interface CountInterface &#123; (a: number, b: number): number;&#125;const count: CountInterface = (x, y) =&gt; &#123;  return x + y&#125;\n4.  接口的继承interface PersonInterface &#123;  name: string;  age: number;&#125;interface StudentInterface extends PersonInterface &#123;  grade: string;&#125;const stu: StudentInterface = &#123;  name: &quot;xxx&quot;,  age: 18,  grade: &quot;xxx&quot;&#125;\n5.  接口的自动合并interface PersonInterface &#123;  name: string;  age: number;&#125;interface PersonInterface &#123;  gender: string;&#125;const p: PersonInterface = &#123;  name: &quot;xxx&quot;,  age: 18,  gender: &quot;xxx&quot;&#125;\n14. 相似概念的区别1. interface和type的区别\n相同点：interface和type都可以用于定义对象结构，两者在许多场景中是可以互换的。  interface PersonInterface &#123;  name: string;  age: number;  speak(): void;&#125;type PersonType = &#123;  name: string;  age: number;  speak(): void;&#125;let p1: PersonInterface = &#123;  name: &quot;xxx&quot;,  age: 18,  speak()&#123;    console.log(&quot;xxx&quot;);  &#125;&#125;let p2: PersonType = &#123;  name: &quot;xxx&quot;,  age: 18,  speak()&#123;    console.log(&quot;xxx&quot;);  &#125;&#125;\n不同点：\ninterface ：更专注于定义对象和类的结构，支持继承与合并。\ntype：可以自定义类型别名，联合类型，交叉类型，但不支持继承和自动合并。\n\n\n\n2. interface和抽象类的区别\n相同点：都用于定义一个类的格式\n不同点：\ninterface：只能描述结构，不能有任何实现代码，一个类可以实现多个接口。\n抽象类：既可以包括抽象方法，又可以包含具体方法，一个类只能继承一个抽象类。\n\n\n\n六、泛型泛型允许我们在定义函数，类或接口时，使用类型参数来表示未指定的类型，这些参数在具体使用时，才能被指定具体类型。泛型能让同一段代码适用于多种类型同时仍保证类型的安全性。\n1. 泛型函数function logData&lt;T,U&gt;(data1: T, data2: U): T | U &#123;  return Data.now() % 2 ? data1 : data2;&#125;console.log(logData&lt;number, bool&gt;(1000, true));console.log(logData&lt;string, number&gt;(&#x27;hello&#x27;, 666));\n2. 泛型接口interface PersonInterface&lt;T&gt; &#123;  name: string;  age: number;  extraInfo: T&#125;type Home = &#123;  address: string;  postalCode: number;&#125;let p: PersonInterface&lt;Home&gt; = &#123;  name: &quot;TOM&quot;,  age: 18,  extraInfo: &#123;    address: &quot;xxxx&quot;,    postalCode: 123485  &#125;&#125;\n3. 泛型类class Person&lt;T&gt; &#123;  constructor(    public name: string,    public age: number,    public extraInfo: T  ) &#123;&#125;  speak()&#123;\tconsole.log(&quot;xxxx&quot;);  &#125;&#125;const p1 = new Person&lt;number&gt;(&quot;xxx&quot;, 18, 250);\n七、类型声明文件.d.ts文件为现有的javascript代码提供类型信息\n// demo.jsexport function add(a, b)&#123;  return a + b;&#125;\n// demo.d.tsdeclare function add(a: number, b: number): number;export(add)\n八、装饰器","categories":["前端"],"tags":["TypeScript"]},{"title":"MySQL","url":"/2025/06/19/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/","content":"基础MySQL的概述数据库相关的概念\n\n\n名称\n全称\n简称\n\n\n\n数据库\n存储数据的仓库，数据是有组织的进行存储\nDataBase(DB)\n\n\n数据库管理系统\n操纵和管理数据库的大型软件\nDataBase Management System(DBMS)\n\n\nSQL\n操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准\nStructured Query Language(SQL)\n\n\n\n主流的关系型数据库管理系统\nORACLE\nMySQL\nSQL Server\nPostgreSQL\n\n\n\nMySQL数据库\n关系型数据库（RDBMS）概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。特点：\n\n\n使用表存储，格式统一，便于维护\n使用SQL语言操作，标准统一，使用方便\n\n\n数据模型DBMS管理多个数据库，每个数据库存储多张表\n\nSQLSQL的通用语法","categories":["数据库"],"tags":["MySQL"]},{"url":"/2025/09/19/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/","content":"命令一、数据库操作1. 创建数据库基础创建语法CREATE DATABASE [DatabaseName];\n此简单形式会使用 ​​model 数据库​​作为模板创建新数据库，所有属性（包括文件大小、增长设置等）都继承自 model 数据库的配置\n详细创建语法（生产环境推荐使用）CREATE DATABASE SMON PRIMARY -- 指定主文件组(    NAME = SM, -- 逻辑文件名，在数据库中唯一    FILENAME = &#x27;/var/opt/mssql/data/SM.mdf&#x27;, -- 物理文件路径    SIZE = 10MB, -- 初始大小，最小512KB    MAXSIZE = 50MB, -- 最大容量，可使用UNLIMITED    FILEGROWTH = 2MB -- 增长增量，可使用百分比(如10%))LOG ON -- 指定事务日志文件(    NAME = SM_log,    FILENAME = &#x27;/var/opt/mssql/data/SM_log.ldf&#x27;,    SIZE = 5MB, -- 不指定则默认为数据文件总大小的25%    MAXSIZE = 30MB,    FILEGROWTH = 1MB);\n高级创建选项-- 创建包含多个数据文件和文件组的数据库CREATE DATABASE InventoryON PRIMARY (    NAME = Inventory_Primary,    FILENAME = &#x27;D:\\Data\\Inventory_Prm.mdf&#x27;,    SIZE = 10MB,    MAXSIZE = 50MB,    FILEGROWTH = 5MB),FILEGROUP FG_Archive -- 用户定义文件组(    NAME = Inventory_Archive,    FILENAME = &#x27;D:\\Data\\Inventory_Arc.ndf&#x27;,    SIZE = 5MB,    MAXSIZE = 25MB,    FILEGROWTH = 5MB)LOG ON(    NAME = Inventory_Log1,    FILENAME = &#x27;D:\\Data\\Inventory_Log1.ldf&#x27;,    SIZE = 5MB,    MAXSIZE = 25MB,    FILEGROWTH = 5MB);-- 指定排序规则创建数据库CREATE DATABASE InternationalDB COLLATE Latin1_General_CI_AS; -- 指定排序规则\n安全检查后创建-- 先检查数据库是否存在IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = &#x27;SM&#x27;)BEGIN    CREATE DATABASE SM;    PRINT &#x27;数据库 SM 创建成功&#x27;;ENDELSEBEGIN    PRINT &#x27;数据库 SM 已存在&#x27;;END\n2. 查看数据库信息基本查看命令### 3. 删除数据库```sql-- 安全删除（如果存在）DROP DATABASE IF EXISTS [DatabaseName];-- 强制删除（断开所有连接）USE master;GOALTER DATABASE [DatabaseName] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;GODROP DATABASE [DatabaseName];\n\n二、表操作1. 创建表-- 基本创建CREATE TABLE [TableName] (    column1 datatype,    column2 datatype,    column3 datatype,   ....);-- 示例：创建学生表CREATE TABLE Students (    StudentID INT PRIMARY KEY,    FirstName VARCHAR(50),    LastName VARCHAR(50),    Age INT,    EnrollmentDate DATE);\n\n2. 修改表-- 添加列ALTER TABLE [TableName]ADD [ColumnName] [DataType];-- 修改列ALTER TABLE [TableName]ALTER COLUMN [ColumnName] [NewDataType];-- 删除列ALTER TABLE [TableName]DROP COLUMN [ColumnName];\n3. 删除表-- 删除表DROP TABLE [TableName];-- 安全删除DROP TABLE IF EXISTS [TableName];\n三、数据操作1. 插入数据-- 插入单行数据INSERT INTO Students (StudentID, FirstName, LastName, Age, EnrollmentDate)VALUES (1, &#x27;John&#x27;, &#x27;Doe&#x27;, 20, &#x27;2023-09-01&#x27;);-- 插入多行数据INSERT INTO Students (StudentID, FirstName, LastName, Age, EnrollmentDate)VALUES (2, &#x27;Jane&#x27;, &#x27;Smith&#x27;, 22, &#x27;2023-09-01&#x27;),(3, &#x27;Tom&#x27;, &#x27;Brown&#x27;, 21, &#x27;2023-09-01&#x27;);\n2. 查询数据-- 查询所有数据SELECT * FROM Students;-- 查询特定列SELECT FirstName, LastName FROM Students;-- 带条件的查询SELECT * FROM Students WHERE Age &gt; 21;-- 排序查询SELECT * FROM Students ORDER BY EnrollmentDate DESC;-- 使用聚合函数SELECT COUNT(*) AS TotalStudents FROM Students;\n3. 更新数据-- 更新数据UPDATE StudentsSET Age = 21WHERE StudentID = 1;-- 更新多个列UPDATE StudentsSET FirstName = &#x27;Johnathan&#x27;, LastName = &#x27;Doe&#x27;WHERE StudentID = 1;\n4. 删除数据-- 删除特定行DELETE FROM Students WHERE StudentID = 1;-- 删除所有数据DELETE FROM Students; -- 注意：这将删除表中的所有数据，但保留表结构\n\n\n四、索引操作1. 创建索引-- 创建单列索引CREATE INDEX IDX_LastName ON Students(LastName);-- 创建多列索引CREATE INDEX IDX_Name_Age ON Students(FirstName, Age);\n2. 删除索引-- 删除索引DROP INDEX IDX_LastName ON Students;\n五、视图操作1. 创建视图-- 创建视图CREATE VIEW StudentView ASSELECT FirstName, LastName, AgeFROM StudentsWHERE Age &gt; 20;\n2. 查询视图-- 查询视图SELECT * FROM StudentView;\n3. 删除视图-- 删除视图DROP VIEW StudentView;\n六、存储过程1. 创建存储过程CREATE PROCEDURE GetStudentById    @StudentID INTASBEGIN    SELECT * FROM Students WHERE StudentID = @StudentID;END;\n2. 执行存储过程EXEC GetStudentById @StudentID = 1;\n3. 删除存储过程DROP PROCEDURE IF EXISTS GetStudentById;\n七、事务处理1. 开始事务BEGIN TRANSACTION;-- 执行多个操作INSERT INTO Students (StudentID, FirstName, LastName, Age, EnrollmentDate)VALUES (4, &#x27;Alice&#x27;, &#x27;Johnson&#x27;, 23, &#x27;2023-09-01&#x27;);-- 提交事务COMMIT;-- 如果出现错误，回滚事务ROLLBACK;\n\n八、权限管理1. 创建用户CREATE USER [Username] FOR LOGIN [LoginName];\n2. 授予权限GRANT SELECT, INSERT, UPDATE ON Students TO [Username];\n3. 撤销权限REVOKE INSERT ON Students FROM [Username];\n4. 删除用户DROP USER [Username];\n九、备份与恢复1. 备份数据库BACKUP DATABASE [DatabaseName]TO DISK = &#x27;D:\\Backups\\DatabaseName.bak&#x27;WITH FORMAT;\n2. 恢复数据库RESTORE DATABASE [DatabaseName]FROM DISK = &#x27;D:\\Backups\\DatabaseName.bak&#x27;WITH REPLACE;"},{"title":"F12开发者工具","url":"/2025/07/02/%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/F12%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/","content":"什么是F12？是浏览器自带的开发调试工具，由于可以直接用F12启动，故简称F12工具\n快速启动方式\nF12\nctrl+shift+i\n\n常规设置\n点击右上角的···可以调节界面的位置\n···–&gt;设置可以调节样式和语言\n点击小手机图标可以更改浏览器UA标签\n\nF12菜单栏\n\n\n英\n汉\n功能\n\n\n\nElements\n查看器\n查看界面的元素\n\n\nConsole\n控制台\n\n\n\nSource\n调试器\n（源代码）\n\n\nNetwork\n网络\n抓包\n\n\nPerformance\n性能\n\n\n\nMemory\n存储\n\n\n\n\nElements：定位元素，查看并更改属性样式\n\n\n"}]